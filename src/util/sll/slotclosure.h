/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2006-2014  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#pragma once

#include <functional>
#include <QObject>
#include "sllconfig.h"

namespace LeechCraft
{
namespace Util
{
	/** @brief Base class for SlotClosure.
	 */
	class UTIL_SLL_API SlotClosureBase : public QObject
	{
		Q_OBJECT

		std::function<void ()> Func_;
	public:
		/** @brief Constructs a SlotClosure running a given \em func with
		 * the given \em parent as a QObject.
		 *
		 * This constructor does not automatically connect to any signals.
		 * Thus, all interesting signals should be manually connected to
		 * the construct object's <code>run()</code> slot:
		 * \code{.cpp}
			const auto closure = new SlotClosure<DeleteLaterPolicy> { someFunc, parent };
			connect (object,
					SIGNAL (triggered ()),
					closure,
					SLOT (run ()));
		   \endcode
		 *
		 * @param[in] func The function to run when a connected signal is
		 * fired.
		 * @param[in] parent The parent object of this SlotClosure.
		 */
		SlotClosureBase (const std::function<void ()>& func, QObject *parent);

		/** @brief Constructs a SlotClosure running a given \em func with
		 * the given \em parent as a QObject on the given \em signal.
		 *
		 * @param[in] func The function to run when a matching signal is
		 * fired.
		 * @param[in] sender The sender of the signal to connect to.
		 * @param[in] signal The signal that should trigger the \em func.
		 * @param[in] parent The parent object of this SlotClosure.
		 */
		SlotClosureBase (const std::function<void ()>& func,
				QObject *sender,
				const char *signal,
				QObject *parent);

		/** @brief Constructs a SlotClosure running a given \em func with
		 * the given \em parent as a QObject on the given list of
		 * \em signals.
		 *
		 * @param[in] func The function to run when a matching signal is
		 * fired.
		 * @param[in] sender The sender of the signal to connect to.
		 * @param[in] signals The list of signals, any of which triggers
		 * the \em func.
		 * @param[in] parent The parent object of this SlotClosure.
		 */
		SlotClosureBase (const std::function<void ()>& func,
				QObject *sender,
				const std::initializer_list<const char*>& signals,
				QObject *parent);

		virtual ~SlotClosureBase () = default;
	public slots:
		/** @brief Triggers the function.
		 */
		virtual void run () = 0;
	};

	/** @brief Executes a given functor upon a signal (or a list of
	 * signals).
	 *
	 * Refer to the documentation of SlotClosureBase to check
	 * constructors and their parameters.
	 *
	 * Typical usage:
	 * \code{.cpp}
		const auto reply = networkAccessManager->get (request);        // say we want to handle a reply
		new Util::SlotClosure<Util::DeleteLaterPolicy>
		{
			[reply]
			{
				if (reply->error () == QNetworkReply::NoError)
					HandleData (reply->readAll ());
				reply->deleteLater ();
			},
			reply,
			SIGNAL (finished ()),
			reply
		};
	   \endcode
	 *
	 * \section LifetimeMgmt Lifetime management.
	 *
	 * The instance of this class can either be deleted after the
	 * matching signal is emitted, or when the object's parent object is
	 * deleted, or when this object is deleted explicitly by the user.
	 * The exact behavior is controlled by the \em FireDestrPolicy
	 * template policy.
	 *
	 * There are two predefined policies: DeleteLaterPolicy and
	 * NoDeletePolicy.
	 *
	 * DeleteLaterPolicy deletes the instance of this class after the
	 * signal is fired for the first time.
	 *
	 * NoDeletePolicy does not delete the object at all. In this case the
	 * object will be deleted either explicitly by the user or when its
	 * parent QObject is deleted.
	 *
	 * @tparam FireDestrPolicy Controls how the object should be
	 * destroyed in response to the watched signal.
	 */
	template<template<typename T> class FireDestrPolicy>
	class SlotClosure : public SlotClosureBase
					  , public FireDestrPolicy<SlotClosureBase>
	{
	public:
		/** @brief Inherits all constructors of SlotClosureBase.
		 */
		using SlotClosureBase::SlotClosureBase;
	public:
		/** @brief Triggers the function and invokes the destroy policy.
		 */
		void run () override
		{
			SlotClosureBase::run ();
			this->Fired ();
		}
	};

	/** @brief Deletes a SlotClosure object after its signal has fired.
	 */
	template<typename T>
	class DeleteLaterPolicy
	{
	public:
		virtual ~DeleteLaterPolicy () {}
	protected:
		void Fired ()
		{
			dynamic_cast<T*> (this)->deleteLater ();
		}
	};

	/** @brief Does not delete a SlotClosure object.
	 */
	template<typename>
	class NoDeletePolicy
	{
	protected:
		void Fired ()
		{
		}
	};
}
}
