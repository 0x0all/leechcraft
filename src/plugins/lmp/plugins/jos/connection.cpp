/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2006-2013  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include "connection.h"
#include <QTemporaryFile>
#include <QDesktopServices>
#include <QStringList>
#include <QtDebug>
#include <libimobiledevice/lockdown.h>

namespace LeechCraft
{
namespace LMP
{
namespace jOS
{
	namespace
	{
		QString GetTemporaryDir ()
		{
			QTemporaryFile file { "lmp_jos_XXXXXX" };
			if (file.open ())
				return file.fileName ();
			else
				return QDesktopServices::storageLocation (QDesktopServices::TempLocation);
		}
	}

	Connection::Connection (const QByteArray& udid)
	: Device_ { MakeRaii<idevice_t> ([udid] (idevice_t *dev)
				{ return idevice_new (dev, udid.constData ()); },
			idevice_free) }
	, Lockdown_ { MakeRaii<lockdownd_client_t> ([this] (lockdownd_client_t *ld)
				{ return lockdownd_client_new_with_handshake (Device_, ld, "LMP jOS"); },
			lockdownd_client_free) }
	, Service_ { MakeRaii<lockdownd_service_descriptor_t> ([this] (lockdownd_service_descriptor_t *service)
				{ return lockdownd_start_service (Lockdown_, "com.apple.afc", service); },
			lockdownd_service_descriptor_free) }
	, AFC_ {  MakeRaii<afc_client_t> ([this] (afc_client_t *afc)
				{ return afc_client_new (Device_, Service_, afc); },
			afc_client_free) }
	, TempDirPath_ { GetTemporaryDir () }
	{
		qDebug () << Q_FUNC_INFO
				<< "created connection to"
				<< udid
				<< "with temp dir"
				<< TempDirPath_;

		for (const auto& dir : QStringList { "Artwork", "Device", "iTunes" })
			CopyDir ("/iTunes_Control/" + dir);

		qDebug () << "done";
	}

	afc_client_t Connection::GetAFC () const
	{
		return AFC_;
	}

	QString Connection::GetFileInfo (const QString& path, const QString& key) const
	{
		char **info = nullptr;
		if (const auto err = afc_get_file_info (AFC_, path.toUtf8 ().constData (), &info))
		{
			qWarning () << Q_FUNC_INFO
					<< "error getting info for"
					<< path
					<< err;
			return {};
		}

		if (!info)
		{
			qWarning () << Q_FUNC_INFO
					<< "couldn't find any properties"
					<< key
					<< "for file"
					<< path
					<< "at all";
			return {};
		}

		auto guard = std::shared_ptr<void> (nullptr,
				[info] (void*) -> void
				{
					for (auto p = info; *p; ++p)
						free (*p);
					free (info);
				});

		QString lastKey;
		for (auto p = info; *p; ++p)
			if (lastKey.isEmpty ())
				lastKey = QString::fromUtf8 (*p);
			else
			{
				if (lastKey == key)
					return QString::fromUtf8 (*p);

				lastKey.clear ();
			}


		qWarning () << Q_FUNC_INFO
				<< "couldn't find property"
				<< key
				<< "for file"
				<< path;
		return {};
	}

	QStringList Connection::ReadDir (const QString& path, QDir::Filters filters)
	{
		char **list = nullptr;
		if (const auto err = afc_read_directory (AFC_, path.toUtf8 ().constData (), &list))
		{
			qWarning () << Q_FUNC_INFO
					<< "error reading"
					<< path
					<< err;
			return {};
		}

		if (!list)
			return {};

		QStringList result;

		for (auto p = list; *p; ++p)
		{
			const auto& filename = QString::fromUtf8 (*p);
			free (*p);

			if (filters == QDir::NoFilter)
			{
				result << filename;
				continue;
			}

			if (filters & QDir::NoDotAndDotDot &&
					(filename == "." || filename == ".."))
				continue;

			if (!(filters & QDir::Hidden) && filename.startsWith ("."))
				continue;

			const auto& filetype = GetFileInfo (path + '/' + filename, "st_ifmt");

			if ((filetype == "S_IFREG" && filters & QDir::Files) ||
				(filetype == "S_IFDIR" && filters & QDir::Dirs) ||
				(filetype == "S_IFLNK" && !(filters & QDir::NoSymLinks)))
				result << filename;
		}

		free (list);

		return result;
	}

	void Connection::CopyDir (const QString& dir)
	{
		qDebug () << "copying dir" << dir;

		for (const auto& file : ReadDir (dir, QDir::Files | QDir::NoDotAndDotDot))
			CopyFile (dir + '/' + file);

		for (const auto& subdir : ReadDir (dir, QDir::Dirs | QDir::NoDotAndDotDot))
			CopyDir (dir + '/' + subdir);
	}

	void Connection::CopyFile (const QString& file)
	{
		qDebug () << "copying file" << file;

		const auto& localFilePath = TempDirPath_ + file;
		const auto& localDirPath = localFilePath.section ('/', 0, -2);

		QDir dir;
		dir.mkpath (localDirPath);

		QFile localFile { localFilePath };
	}
}
}
}
