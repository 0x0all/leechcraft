/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2006-2013  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include "sourceobject.h"
#include <QtDebug>
#include <gst/gst.h>
#include "audiosource.h"
#include "path.h"

namespace LeechCraft
{
namespace LMP
{
	namespace
	{
		void CbNewpad (GstElement *decodebin, GstPad *pad, gpointer data)
		{
			static_cast<SourceObject*> (data)->HandleNewpad (decodebin, pad);
		}
	}

	SourceObject::SourceObject (QObject *parent)
	: QObject (parent)
	, Dec_ (gst_element_factory_make ("uridecodebin", "decoder"))
	, Path_ (nullptr)
	{
		g_signal_connect (Dec_, "pad-added", G_CALLBACK (CbNewpad), this);
		/*
		Obj_->setTickInterval (1000);
		Obj_->setPrefinishMark (2000);

		connect (Obj_,
				SIGNAL (aboutToFinish ()),
				this,
				SIGNAL (aboutToFinish ()));
		connect (Obj_,
				SIGNAL (finished ()),
				this,
				SIGNAL (finished ()));
		connect (Obj_,
				SIGNAL (metaDataChanged ()),
				this,
				SIGNAL (metaDataChanged ()));
		connect (Obj_,
				SIGNAL (bufferStatus (int)),
				this,
				SIGNAL (bufferStatus (int)));
		connect (Obj_,
				SIGNAL (totalTimeChanged (qint64)),
				this,
				SIGNAL (totalTimeChanged (qint64)));
		connect (Obj_,
				SIGNAL (tick (qint64)),
				this,
				SIGNAL (tick (qint64)));
				*/
	}

	SourceObject::~SourceObject ()
	{
	}


	bool SourceObject::IsSeekable () const
	{
// 		return Obj_->isSeekable ();
	}

	SourceObject::State SourceObject::GetState () const
	{
// 		return ToState (Obj_->state ());
	}

	QString SourceObject::GetErrorString () const
	{
// 		return Obj_->errorString ();
	}

	QStringList SourceObject::GetMetadata (Metadata field) const
	{
// 		switch (field)
// 		{
// 		case Metadata::Artist:
// 			return Obj_->metaData (Phonon::ArtistMetaData);
// 		case Metadata::Album:
// 			return Obj_->metaData (Phonon::AlbumMetaData);
// 		case Metadata::Title:
// 			return Obj_->metaData (Phonon::TitleMetaData);
// 		case Metadata::Genre:
// 			return Obj_->metaData (Phonon::GenreMetaData);
// 		case Metadata::Tracknumber:
// 			return Obj_->metaData (Phonon::TracknumberMetaData);
// 		}
//
// 		qWarning () << Q_FUNC_INFO
// 				<< "unknown field"
// 				<< static_cast<int> (field);
//
// 		return {};
	}

	qint64 SourceObject::GetCurrentTime () const
	{
// 		return Obj_->currentTime ();
	}

	qint64 SourceObject::GetRemainingTime () const
	{
// 		return Obj_->remainingTime ();
	}

	qint64 SourceObject::GetTotalTime () const
	{
// 		return Obj_->totalTime ();
	}

	void SourceObject::Seek (qint64 pos)
	{
// 		Obj_->seek (pos);
	}

	void SourceObject::SetTransitionTime (int time)
	{
// 		Obj_->setTransitionTime (time);
	}

	AudioSource SourceObject::GetCurrentSource () const
	{
		return {};
	}

	void SourceObject::SetCurrentSource (const AudioSource& source)
	{
		const auto& path = source.ToUrl ().toString ();
		g_object_set (G_OBJECT (Dec_), "uri", path.toUtf8 ().constData (), 0);
	}

	void SourceObject::PrepareNextSource (const AudioSource& source)
	{
		NextSource_ = source;
	}

	void SourceObject::Play ()
	{
		gchar *value = nullptr;
		g_object_get (G_OBJECT (Dec_), "uri", &value, nullptr);
		if (strlen (value) <= 0)
		{
			qDebug () << Q_FUNC_INFO
					<< "current source is invalid, setting next one";
			SetCurrentSource (NextSource_);
			ClearQueue ();
		}
		g_free (value);

		gst_element_set_state (Path_->GetPipeline (), GST_STATE_PLAYING);
	}

	void SourceObject::Pause ()
	{
		gst_element_set_state (Path_->GetPipeline (), GST_STATE_PAUSED);
	}

	void SourceObject::Stop ()
	{
		gst_element_set_state (Path_->GetPipeline (), GST_STATE_NULL);
	}

	void SourceObject::Clear ()
	{
		ClearQueue ();
		gst_element_set_state (Path_->GetPipeline (), GST_STATE_NULL);
	}

	void SourceObject::ClearQueue ()
	{
		NextSource_ = AudioSource ();
	}

	void SourceObject::HandleNewpad (GstElement *decodebin, GstPad *pad)
	{
		auto audiopad = gst_element_get_static_pad (Path_->GetAudioBin (), "sink");
		if (GST_PAD_IS_LINKED (audiopad))
		{
			g_object_unref (audiopad);
			return;
		}

		auto caps = gst_pad_get_caps (pad);
		auto str = gst_caps_get_structure (caps, 0);

		if (!g_strrstr (gst_structure_get_name (str), "audio"))
		{
			qWarning () << Q_FUNC_INFO
					<< "not an audio";
			gst_caps_unref (caps);
			gst_object_unref (audiopad);
			return;
		}

		gst_pad_link (pad, audiopad);

		gst_caps_unref (caps);
		gst_object_unref (audiopad);
	}

	void SourceObject::HandleAboutToFinish ()
	{
		emit aboutToFinish ();
		if (NextSource_.IsEmpty ())
			return;

		const auto& path = NextSource_.ToUrl ().toString ();
		g_object_set (G_OBJECT (Dec_), "uri", path.toUtf8 ().constData (), 0);

		ClearQueue ();
	}

	namespace
	{
		gboolean CbBus (GstBus *bus, GstMessage *message, gpointer data)
		{
			switch (GST_MESSAGE_TYPE (message))
			{
			default:
				break;
			}

			return true;
		}

		gboolean CbAboutToFinish (GstElement*, gpointer data)
		{
			static_cast<SourceObject*> (data)->HandleAboutToFinish ();
		}
	}

	void SourceObject::AddToPath (Path *path)
	{
		gst_bin_add_many (GST_BIN (path->GetPipeline ()), Dec_, nullptr);
		Path_ = path;

		auto bus = gst_pipeline_get_bus (GST_PIPELINE (path->GetPipeline ()));
		gst_bus_add_watch (bus, CbBus, this);
		gst_object_unref (bus);

		g_signal_connect (Dec_,
				"drained", G_CALLBACK (CbAboutToFinish), this);
	}
}
}
