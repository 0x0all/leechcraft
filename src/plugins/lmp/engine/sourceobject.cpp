/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2006-2013  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include "sourceobject.h"
#include "audiosource.h"
#include <QtDebug>
#include "phonon/mediaobject.h"

namespace LeechCraft
{
namespace LMP
{
	namespace
	{
		SourceObject::State ToState (Phonon::State state)
		{
			switch (state)
			{
			case Phonon::State::BufferingState:
			case Phonon::State::LoadingState:
				return SourceObject::State::Buffering;
			case Phonon::State::StoppedState:
				return SourceObject::State::Stopped;
			case Phonon::State::PausedState:
				return SourceObject::State::Paused;
			case Phonon::State::PlayingState:
				return SourceObject::State::Playing;
			case Phonon::State::ErrorState:
				return SourceObject::State::Error;
			}

			qWarning () << Q_FUNC_INFO
					<< "unknown state"
					<< state;
			return SourceObject::State::Error;
		}
	}

	SourceObject::SourceObject (QObject *parent)
	: QObject (parent)
	, Obj_ (new Phonon::MediaObject (this))
	{
		Obj_->setTickInterval (1000);
		Obj_->setPrefinishMark (2000);

		connect (Obj_,
				SIGNAL (currentSourceChanged (Phonon::MediaSource)),
				this,
				SLOT (handlePhononSourceChanged (Phonon::MediaSource)));
		connect (Obj_,
				SIGNAL (stateChanged (Phonon::State, Phonon::State)),
				this,
				SLOT (handlePhononStateChanged (Phonon::State, Phonon::State)));

		connect (Obj_,
				SIGNAL (aboutToFinish ()),
				this,
				SIGNAL (aboutToFinish ()));
		connect (Obj_,
				SIGNAL (finished ()),
				this,
				SIGNAL (finished ()));
		connect (Obj_,
				SIGNAL (metaDataChanged ()),
				this,
				SIGNAL (metaDataChanged ()));
		connect (Obj_,
				SIGNAL (bufferStatus (int)),
				this,
				SIGNAL (bufferStatus (int)));
		connect (Obj_,
				SIGNAL (totalTimeChanged (qint64)),
				this,
				SIGNAL (totalTimeChanged (qint64)));
		connect (Obj_,
				SIGNAL (tick (qint64)),
				this,
				SIGNAL (tick (qint64)));
	}

	bool SourceObject::IsSeekable () const
	{
		return Obj_->isSeekable ();
	}

	SourceObject::State SourceObject::GetState () const
	{
		return ToState (Obj_->state ());
	}

	QString SourceObject::GetErrorString () const
	{
		return Obj_->errorString ();
	}

	QStringList SourceObject::GetMetadata (Metadata field) const
	{
		switch (field)
		{
		case Metadata::Artist:
			return Obj_->metaData (Phonon::ArtistMetaData);
		case Metadata::Album:
			return Obj_->metaData (Phonon::AlbumMetaData);
		case Metadata::Title:
			return Obj_->metaData (Phonon::TitleMetaData);
		case Metadata::Genre:
			return Obj_->metaData (Phonon::GenreMetaData);
		case Metadata::Tracknumber:
			return Obj_->metaData (Phonon::TracknumberMetaData);
		}

		qWarning () << Q_FUNC_INFO
				<< "unknown field"
				<< static_cast<int> (field);

		return {};
	}

	qint64 SourceObject::GetCurrentTime () const
	{
		return Obj_->currentTime ();
	}

	qint64 SourceObject::GetRemainingTime () const
	{
		return Obj_->remainingTime ();
	}

	qint64 SourceObject::GetTotalTime () const
	{
		return Obj_->totalTime ();
	}

	void SourceObject::Seek (qint64 pos)
	{
		Obj_->seek (pos);
	}

	void SourceObject::SetTransitionTime (int time)
	{
		Obj_->setTransitionTime (time);
	}

	AudioSource SourceObject::GetCurrentSource () const
	{
		return AudioSource::FromPhonon (Obj_->currentSource ());
	}

	void SourceObject::SetCurrentSource (const AudioSource& source)
	{
		Obj_->setCurrentSource (source.ToPhonon ());
	}

	void SourceObject::Enqueue (const AudioSource& source)
	{
		Obj_->enqueue (source.ToPhonon ());
	}

	void SourceObject::Play ()
	{
		Obj_->play ();
	}

	void SourceObject::Pause ()
	{
		Obj_->pause ();
	}

	void SourceObject::Stop ()
	{
		Obj_->stop ();
	}

	void SourceObject::Clear ()
	{
		Obj_->clear ();
	}

	void SourceObject::ClearQueue ()
	{
		Obj_->clearQueue ();
	}

	Phonon::MediaObject* SourceObject::ToPhonon () const
	{
		return Obj_;
	}

	void SourceObject::handlePhononSourceChanged (const Phonon::MediaSource& source)
	{
		emit currentSourceChanged (AudioSource::FromPhonon (source));
	}

	void SourceObject::handlePhononStateChanged (Phonon::State newState, Phonon::State oldState)
	{
		emit stateChanged (ToState (newState), ToState (oldState));
	}
}
}
