/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2006-2014  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include "playerrulesmanager.h"
#include <QUrl>
#include <QStandardItemModel>
#include <QtConcurrentMap>
#include <interfaces/structures.h>
#include <interfaces/core/ipluginsmanager.h>
#include <interfaces/an/ianemitter.h>
#include <interfaces/an/ianrulesstorage.h>
#include <interfaces/an/constants.h>
#include <util/structuresops.h>
#include <util/util.h>
#include <util/sll/qtutil.h>
#include <util/sll/prelude.h>
#include "core.h"
#include "player.h"

Q_DECLARE_METATYPE (QList<LeechCraft::Entity>)

namespace LeechCraft
{
namespace LMP
{
	PlayerRulesManager::PlayerRulesManager (QStandardItemModel *model, QObject *parent)
	: QObject { parent }
	, Model_ { model }
	{
		connect (model,
				SIGNAL (rowsInserted (QModelIndex, int, int)),
				this,
				SLOT (insertRows (QModelIndex, int, int)));
		connect (model,
				SIGNAL (rowsAboutToBeRemoved (QModelIndex, int, int)),
				this,
				SLOT (removeRows (QModelIndex, int, int)));
		connect (model,
				SIGNAL (modelReset ()),
				this,
				SLOT (handleReset ()));
	}

	namespace
	{
		struct StringMatcher : boost::static_visitor<bool>
		{
			const QString Value_;

			StringMatcher (const QString& val)
			: Value_ { val }
			{
			}

			bool operator() (const ANStringFieldValue& value) const
			{
				return value.Rx_.exactMatch (Value_) == value.Contains_;
			}

			template<typename T>
			bool operator() (const T&) const
			{
				return false;
			}
		};

		struct IntMatcher : boost::static_visitor<bool>
		{
			const int Value_;

			IntMatcher (int val)
			: Value_ { val }
			{
			}

			bool operator() (const ANIntFieldValue& value) const
			{
				return ((value.Ops_ & ANIntFieldValue::OEqual) && Value_ == value.Boundary_) ||
						((value.Ops_ & ANIntFieldValue::OGreater) && Value_ > value.Boundary_) ||
						((value.Ops_ & ANIntFieldValue::OLess) && Value_ < value.Boundary_);
			}

			template<typename T>
			bool operator() (const T&) const
			{
				return false;
			}
		};

		template<typename U, typename T>
		bool MatchField (const Entity& rule, const QString& fieldId, const T& value, bool& hadSome)
		{
			const auto pos = rule.Additional_.find (fieldId);
			if (pos == rule.Additional_.end ())
				return true;

			hadSome = true;
			auto variant = pos.value ().value<ANFieldValue> ();
			return boost::apply_visitor (U { value }, variant);
		}

		bool Matches (const Entity& rule, const MediaInfo& info)
		{
			bool hadSome = false;
			auto matchStr = [&rule, &hadSome] (const QString& fieldId, const QString& value)
			{
				return MatchField<StringMatcher> (rule, fieldId, value, hadSome);
			};
			auto matchInt = [&rule, &hadSome] (const QString& fieldId, int value)
			{
				return MatchField<IntMatcher> (rule, fieldId, value, hadSome);
			};

			if (!matchInt (AN::Field::MediaLength, info.Length_) ||
					!matchStr (AN::Field::MediaArtist, info.Artist_) ||
					!matchStr (AN::Field::MediaAlbum, info.Album_) ||
					!matchStr (AN::Field::MediaTitle, info.Title_))
				return false;

			auto url = info.Additional_.value ("URL").toUrl ();
			if (url.isEmpty ())
				url = QUrl::fromLocalFile (info.LocalPath_);

			if (!matchStr (AN::Field::MediaPlayerURL, url.toEncoded ()))
				return false;

			return hadSome;
		}

		void ReapplyRules (const QList<QStandardItem*>& items, const QList<Entity>& rules)
		{
			qDebug () << Q_FUNC_INFO;

			using RulesMap_t = QHash<QStandardItem*, QList<Entity>>;
			RulesMap_t newRules;

			if (!rules.isEmpty ())
			{
				const auto& infoCache = Util::Map (items,
						[] (QStandardItem *item)
						{
							return qMakePair (item, item->data (Player::Role::Info).value<MediaInfo> ());
						});

				for (const auto& rule : rules)
					for (const auto infoCache : infoCache)
						if (Matches (rule, infoCache.second))
							newRules [infoCache.first] << rule;
			}

			for (const auto item : items)
			{
				const auto& matching = newRules.value (item);
				const auto& current = item->data (Player::Role::MatchingRules).value<QList<Entity>> ();
				if (current != matching)
					item->setData (matching.isEmpty () ? QVariant {} : QVariant::fromValue (matching),
							Player::Role::MatchingRules);
			}

			qDebug () << "done" << newRules.size ();
		}
	}

	void PlayerRulesManager::InitializePlugins ()
	{
		const auto plugMgr = Core::Instance ().GetProxy ()->GetPluginsManager ();
		for (auto storage : plugMgr->GetAllCastableRoots<IANRulesStorage*> ())
			connect (storage,
					SIGNAL (rulesChanged ()),
					this,
					SLOT (handleRulesChanged ()));

		refillRules ();

		ReapplyRules (ManagedItems_, Rules_);
	}

	void PlayerRulesManager::insertRows (const QModelIndex& parent, int first, int last)
	{
		QList<QStandardItem*> list;
		for (int i = first; i <= last; ++i)
			list << Model_->itemFromIndex (Model_->index (i, 0, parent));

		QList<QStandardItem*> newItems;
		for (int i = 0; i < list.size (); ++i)
		{
			const auto item = list.at (i);

			if (!item->data (Player::IsAlbum).toBool ())
				newItems << item;

			for (int j = 0; j < item->rowCount (); ++j)
				list << item->child (j);
		}

		ReapplyRules (newItems, Rules_);

		ManagedItems_ += newItems;
	}

	void PlayerRulesManager::removeRows (const QModelIndex& parent, int first, int last)
	{
		QList<QStandardItem*> list;
		for (int i = first; i <= last; ++i)
			list << Model_->itemFromIndex (Model_->index (i, 0, parent));

		for (int i = 0; i < list.size (); ++i)
		{
			const auto item = list.at (i);

			ManagedItems_.removeOne (item);

			for (int j = 0; j < item->rowCount (); ++j)
				list << item->child (j);
		}
	}

	void PlayerRulesManager::handleReset ()
	{
		ManagedItems_.clear ();
		if (const auto rc = Model_->rowCount ())
			insertRows ({}, 0, rc - 1);
	}

	void PlayerRulesManager::refillRules ()
	{
		Rules_.clear ();

		const auto plugMgr = Core::Instance ().GetProxy ()->GetPluginsManager ();
		for (auto storage : plugMgr->GetAllCastableTo<IANRulesStorage*> ())
			Rules_ += storage->GetAllRules (AN::CatMediaPlayer);
	}

	void PlayerRulesManager::handleRulesChanged ()
	{
		refillRules ();
		ReapplyRules (ManagedItems_, Rules_);
	}
}
}
