/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2006-2014  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#pragma once

#include <unordered_map>
#include <boost/filesystem/path.hpp>
#include <QIcon>
#include <QString>
#include <QAbstractItemModel>
#include <util/models/modelitembase.h>

namespace LeechCraft
{
namespace Plugins
{
namespace BitTorrent
{
	template<typename T>
	struct TorrentNodeInfoBase : public Util::ModelItemBase<T>
	{
		QIcon Icon_;

		QString Name_;

		// (ColumnPath, RawDataRole)
		boost::filesystem::path ParentPath_;

		// (ColumnPath, RoleFileIndex)
		int FileIndex_ = -1;

		// (ColumnPath, RoleSize)
		// (2, RoleSize)
		// (ColumnProgress, RawDataRole)
		qulonglong SubtreeSize_ = 0;

		TorrentNodeInfoBase (const std::shared_ptr<T>& parent)
		: Util::ModelItemBase<T> { parent }
		{
		}

		boost::filesystem::path GetFullPath () const
		{
			return ParentPath_ / Name_.toStdString ();
		}
	};

	template<typename T>
	using TorrentNodeInfoBase_ptr = std::shared_ptr<TorrentNodeInfoBase<T>>;

	template<typename T>
	class TorrentFilesModelBase : public QAbstractItemModel
	{
		const QStringList HeaderData_;

		struct Hash : public std::unary_function<boost::filesystem::path, size_t>
		{
			size_t operator() (const boost::filesystem::path& path) const
			{
				return std::hash<std::string> {} (path.string ());
			}
		};
	protected:
		std::unordered_map<boost::filesystem::path, std::shared_ptr<T>, Hash> Path2Node_;

		const std::shared_ptr<T> RootNode_;

		boost::filesystem::path BasePath_;

		int FilesInTorrent_ = 0;

		TorrentFilesModelBase (const QStringList& headers, QObject *parent = nullptr)
		: QAbstractItemModel { parent }
		, HeaderData_ { headers }
		, RootNode_ { std::make_shared<T> (std::shared_ptr<T> {}) }
		{
		}

		int columnCount (const QModelIndex&) const override final
		{
			return HeaderData_.size ();
		}

		QVariant headerData (int h, Qt::Orientation orient, int role) const override final
		{
			if (orient == Qt::Horizontal && role == Qt::DisplayRole)
				return HeaderData_.value (h);

			return {};
		}

		QModelIndex index (int row, int col, const QModelIndex& parent = {}) const override final
		{
			if (!hasIndex (row, col, parent))
				return {};

			const auto nodePtr = parent.isValid () ?
					static_cast<T*> (parent.internalPointer ()) :
					RootNode_.get ();

			if (const auto childNode = nodePtr->GetChild (row))
				return createIndex (row, col, childNode.get ());
			return {};
		}

		QModelIndex parent (const QModelIndex& index) const override final
		{
			if (!index.isValid ())
				return {};

			const auto nodePtr = static_cast<T*> (index.internalPointer ());
			const auto parent = nodePtr->GetParent ();

			if (parent == RootNode_)
				return {};

			return createIndex (parent->GetRow (), 0, parent.get ());
		}

		int rowCount (const QModelIndex& parent) const override final
		{
			if (parent.column () > 0)
				return 0;

			const auto nodePtr = parent.isValid () ?
					static_cast<T*> (parent.internalPointer ()) :
					RootNode_.get ();
			return nodePtr->GetRowCount ();
		}

		void UpdateSizeGraph (const std::shared_ptr<T>& node)
		{
			if (!node->GetRowCount ())
				return;

			qulonglong size = 0;
			qulonglong done = 0;
			for (const auto& child : *node)
			{
				UpdateSizeGraph (child);
				size += child->SubtreeSize_;
				done += child->SubtreeSize_ * child->Progress_;
			}
			node->SubtreeSize_ = size;
			node->Progress_ = size ? static_cast<double> (done) / size : 1;
		}
	public:
		void Clear ()
		{
			if (!RootNode_->GetRowCount ())
				return;

			BasePath_.clear ();

			beginRemoveRows ({}, 0, RootNode_->GetRowCount () - 1);
			RootNode_->EraseChildren (RootNode_->begin (), RootNode_->end ());
			endRemoveRows ();

			FilesInTorrent_ = 0;
			Path2Node_.clear ();
		}
	};
}
}
}
