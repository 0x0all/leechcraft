/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2006-2014  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include "torrenttabfileswidget.h"
#include <QMenu>
#include <QTimer>
#include <QSortFilterProxyModel>
#include <util/gui/clearlineeditaddon.h>
#include <util/sll/slotclosure.h>
#include <util/util.h>
#include "filesviewdelegate.h"
#include "core.h"
#include "torrentfilesmodel.h"

namespace LeechCraft
{
namespace Plugins
{
namespace BitTorrent
{
	namespace
	{
		class FilesProxyModel : public QSortFilterProxyModel
		{
		public:
			FilesProxyModel (QObject *parent)
			: QSortFilterProxyModel { parent }
			{
				setDynamicSortFilter (true);
			}
		protected:
			bool filterAcceptsRow (int row, const QModelIndex& parent) const override
			{
				const auto& idx = sourceModel ()->index (row, TorrentFilesModel::ColumnPath, parent);

				if (idx.data ().toString ().contains (filterRegExp ().pattern (), Qt::CaseInsensitive))
					return true;

				const auto rc = sourceModel ()->rowCount (idx);
				for (int i = 0; i < rc; ++i)
					if (filterAcceptsRow (i, idx))
						return true;

				return false;
			}
		};
	}

	TorrentTabFilesWidget::TorrentTabFilesWidget (QWidget *parent)
	: QWidget { parent }
	, ProxyModel_ { new FilesProxyModel { this } }
	{
		Ui_.setupUi (this);

		new Util::ClearLineEditAddon { Core::Instance ()->GetProxy (), Ui_.SearchLine_ };

		ProxyModel_->setSortRole (TorrentFilesModel::RoleSort);
		Ui_.FilesView_->setItemDelegate (new FilesViewDelegate (Ui_.FilesView_));
		Ui_.FilesView_->setModel (ProxyModel_);

		connect (Ui_.FilesView_->selectionModel (),
				SIGNAL (currentChanged (const QModelIndex&, const QModelIndex&)),
				this,
				SLOT (currentFileChanged (const QModelIndex&)));

		currentFileChanged ({});

		connect (Ui_.FilesView_,
				SIGNAL (doubleClicked (const QModelIndex&)),
				this,
				SLOT (handleFileActivated (const QModelIndex&)));

		connect (Ui_.SearchLine_,
				SIGNAL (textChanged (QString)),
				ProxyModel_,
				SLOT (setFilterFixedString (QString)));
		connect (Ui_.SearchLine_,
				SIGNAL (textChanged (QString)),
				Ui_.FilesView_,
				SLOT (expandAll ()));
	}

	void TorrentTabFilesWidget::SetCurrentIndex (int index)
	{
		const auto oldModel = ProxyModel_->sourceModel ();
		ProxyModel_->setSourceModel (nullptr);
		delete oldModel;

		Ui_.SearchLine_->clear ();

		const auto newTFM = Core::Instance ()->GetTorrentFilesModel (index);
		ProxyModel_->setSourceModel (newTFM);
		QTimer::singleShot (0,
				Ui_.FilesView_,
				SLOT (expandAll ()));

		Ui_.SearchLine_->setVisible (Core::Instance ()->GetTorrentFiles (index).size () > 1);

		const auto& fm = Ui_.FilesView_->fontMetrics ();
		auto header = Ui_.FilesView_->header ();
		header->resizeSection (0, fm.width ("some very long file name or a directory name in a torrent file"));
	}

	void TorrentTabFilesWidget::currentFileChanged (const QModelIndex& index)
	{
		Ui_.FilePriorityRegulator_->setEnabled (index.isValid ());

		if (!index.isValid ())
		{
			Ui_.FilePath_->setText ("");
			Ui_.FileProgress_->setText ("");
			Ui_.FilePriorityRegulator_->blockSignals (true);
			Ui_.FilePriorityRegulator_->setValue (0);
			Ui_.FilePriorityRegulator_->blockSignals (false);
		}
		else
		{
			auto path = index.data (TorrentFilesModel::RoleFullPath).toString ();
			path = QApplication::fontMetrics ()
				.elidedText (path,
						Qt::ElideLeft,
						Ui_.FilePath_->width ());
			Ui_.FilePath_->setText (path);

			QModelIndex sindex = index.sibling (index.row (),
					TorrentFilesModel::ColumnProgress);
			double progress = sindex.data (TorrentFilesModel::RoleProgress).toDouble ();
			qint64 size = sindex.data (TorrentFilesModel::RoleSize).toLongLong ();
			qint64 done = progress * size;
			Ui_.FileProgress_->setText (tr ("%1% (%2 of %3)")
					.arg (progress * 100, 0, 'f', 1)
					.arg (Util::MakePrettySize (done))
					.arg (Util::MakePrettySize (size)));

			Ui_.FilePriorityRegulator_->blockSignals (true);
			if (index.model ()->rowCount (index))
				Ui_.FilePriorityRegulator_->setValue (1);
			else
			{
				QModelIndex prindex = index.sibling (index.row (),
						TorrentFilesModel::ColumnPriority);
				int priority = prindex.data ().toInt ();
				Ui_.FilePriorityRegulator_->setValue (priority);
			}
			Ui_.FilePriorityRegulator_->blockSignals (false);
		}
	}

	void TorrentTabFilesWidget::on_FilePriorityRegulator__valueChanged (int prio)
	{
		QModelIndex current = Ui_.FilesView_->selectionModel ()->currentIndex ();

		QModelIndexList selected = Ui_.FilesView_->selectionModel ()->selectedRows ();
		if (!selected.contains (current))
			selected.append (current);

		struct Applier
		{
			Applier (TorrentFilesModel *model, const QModelIndexList& indexes, int prio)
			{
				Q_FOREACH (QModelIndex s, indexes)
				{
					int rows = s.model ()->rowCount (s);
					if (rows)
					{
						QModelIndexList childs;
						for (int i = 0; i < rows; ++i)
							childs.append (s.child (i, TorrentFilesModel::ColumnPriority));
						Applier (model, childs, prio);
					}
					else
						model->setData (s.sibling (s.row (),
									TorrentFilesModel::ColumnPriority), prio);
				}
			}
		};

		auto model = static_cast<TorrentFilesModel*> (Ui_.FilesView_->model ());
		Applier (model, selected, prio);
	}

	void TorrentTabFilesWidget::on_FilesView__customContextMenuRequested (const QPoint& pos)
	{
		const auto& idx = Ui_.FilesView_->indexAt (pos);
		if (!idx.isValid ())
			return;

		QMenu menu;
		menu.addAction (tr ("Expand all"), Ui_.FilesView_, SLOT (expandAll ()));
		menu.addAction (tr ("Collapse all"), Ui_.FilesView_, SLOT (collapseAll ()));

		menu.exec (Ui_.FilesView_->viewport ()->mapToGlobal (pos));
	}

	void TorrentTabFilesWidget::handleFileActivated (const QModelIndex& index)
	{
		auto model = static_cast<const TorrentFilesModel*> (index.model ());
		model->HandleFileActivated (index);
	}
}
}
}
