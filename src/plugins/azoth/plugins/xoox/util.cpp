/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2006-2014  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include "util.h"
#include <memory>
#include <QObject>
#include <QHash>
#include <QDomDocument>
#include <QDomElement>
#include <QDialog>
#include <QDialogButtonBox>
#include <QVBoxLayout>
#include <QDataStream>
#include <QFile>
#include <QtDebug>
#include <QXmppPresence.h>
#include <QXmppUtils.h>
#include <QXmppGlobal.h>
#include <util/sll/parsejson.h>
#include "entrybase.h"
#include "capsdatabase.h"

QDataStream& operator<< (QDataStream& out, const QXmppDiscoveryIq::Identity& id)
{
	out << static_cast<quint8> (1)
		<< id.category ()
		<< id.language ()
		<< id.name ()
		<< id.type ();
	return out;
}

QDataStream& operator>> (QDataStream& in, QXmppDiscoveryIq::Identity& id)
{
	quint8 version = 0;
	in >> version;
	if (version != 1)
	{
		qWarning () << Q_FUNC_INFO
				<< "unknown version"
				<< version;
		return in;
	}

	QString category, language, name, type;
	in >> category
		>> language
		>> name
		>> type;
	id.setCategory (category);
	id.setLanguage (language);
	id.setName (name);
	id.setType (type);

	return in;
}

namespace LeechCraft
{
namespace Azoth
{
namespace Xoox
{
namespace XooxUtil
{
	const QString NsRegister { "jabber:iq:register" };

	QString RoleToString (const QXmppMucItem::Role& role)
	{
		switch (role)
		{
		case QXmppMucItem::NoRole:
			return QObject::tr ("guest");
		case QXmppMucItem::VisitorRole:
			return QObject::tr ("visitor");
		case QXmppMucItem::ParticipantRole:
			return QObject::tr ("participant");
		case QXmppMucItem::ModeratorRole:
			return QObject::tr ("moderator");
		default:
			return QObject::tr ("unspecified");
		}
	}

	QString AffiliationToString (const QXmppMucItem::Affiliation& affiliation)
	{
		switch (affiliation)
		{
		case QXmppMucItem::OutcastAffiliation:
			return QObject::tr ("outcast");
		case QXmppMucItem::NoAffiliation:
			return QObject::tr ("newcomer");
		case QXmppMucItem::MemberAffiliation:
			return QObject::tr ("member");
		case QXmppMucItem::AdminAffiliation:
			return QObject::tr ("admin");
		case QXmppMucItem::OwnerAffiliation:
			return QObject::tr ("owner");
		default:
			return QObject::tr ("unspecified");
		}
	}

	namespace
	{
		QPair<QString, StaticClientInfo> ParseClientIdObj (const QVariantMap& map)
		{
			const auto& node = map ["node"].toString ();
			const auto& id = map ["id"].toString ();
			const auto& name = map ["name"].toString ();

			if (node.isEmpty () || id.isEmpty () || name.isEmpty ())
				qWarning () << Q_FUNC_INFO
						<< "missing data for map"
						<< map;

			return { node, { id, name } };
		}

		class StaticClientInfoHolder
		{
			QHash<QString, StaticClientInfo> FullMatches_;
			QList<QPair<QString, StaticClientInfo>> PartialMatches_;
		public:
			StaticClientInfoHolder ()
			{
				QFile file { ":/azoth/xoox/resources/data/clientids.json" };
				if (!file.open (QIODevice::ReadOnly))
				{
					qWarning () << Q_FUNC_INFO
							<< "unable to open file:"
							<< file.errorString ();
					return;
				}

				const auto& json = Util::ParseJson (&file, Q_FUNC_INFO).toMap ();

				for (const auto& itemVar : json ["fullMatches"].toList ())
				{
					const auto& pair = ParseClientIdObj (itemVar.toMap ());
					if (FullMatches_.contains (pair.first))
						qWarning () << Q_FUNC_INFO
								<< "duplicate node:"
								<< pair.first;
					FullMatches_ [pair.first] = pair.second;
				}

				for (const auto& itemVar : json ["partialMatches"].toList ())
					PartialMatches_ << ParseClientIdObj (itemVar.toMap ());

				std::sort (PartialMatches_.begin (), PartialMatches_.end (),
						[] (const auto& left, const auto& right) { return left.first < right.first; });
			}

			StaticClientInfo operator[] (const QString& node) const
			{
				const auto pos = FullMatches_.find (node);
				if (pos != FullMatches_.end ())
					return *pos;

				for (auto i = PartialMatches_.begin (), end = PartialMatches_.end (); i != end; ++i)
					if (node.startsWith (i->first))
						return i->second;

				return {};
			}
		};
	}

	StaticClientInfo GetStaticClientInfo (const QString& node)
	{
		static const StaticClientInfoHolder holder;
		return holder [node];
	}

	QDomElement XmppElem2DomElem (const QXmppElement& elem)
	{
		QByteArray arr;
		QXmlStreamWriter w (&arr);
		elem.toXml (&w);

		QDomDocument doc;
		doc.setContent (arr, true);
		return doc.documentElement ();
	}

	QXmppElement Form2XmppElem (const QXmppDataForm& form)
	{
		QByteArray formData;
		QXmlStreamWriter w (&formData);
		form.toXml (&w);
		QDomDocument doc;
		doc.setContent (formData);
		return doc.documentElement ();
	}

	bool RunFormDialog (QWidget *widget)
	{
		QDialog *dialog (new QDialog ());
		dialog->setWindowTitle (widget->windowTitle ());
		dialog->setLayout (new QVBoxLayout ());
		dialog->layout ()->addWidget (widget);
		QDialogButtonBox *box = new QDialogButtonBox (QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
		dialog->layout ()->addWidget (box);
		QObject::connect (box,
				SIGNAL (accepted ()),
				dialog,
				SLOT (accept ()));
		QObject::connect (box,
				SIGNAL (rejected ()),
				dialog,
				SLOT (reject ()));

		const bool result = dialog->exec () == QDialog::Accepted;
		dialog->deleteLater ();
		return result;
	}

	bool CheckUserFeature (EntryBase *base, const QString& variant,
			const QString& feature, const CapsDatabase *capsDB)
	{
		if (variant.isEmpty ())
			return true;

		const QByteArray& ver = base->GetVariantVerString (variant);
		if (ver.isEmpty ())
			return true;

		const auto& feats = capsDB->Get (ver);
		if (feats.isEmpty ())
			return true;

		return feats.contains (feature);
	}

	QXmppMessage Forwarded2Message (const QXmppElement& wrapper)
	{
		const auto& forwardedElem = wrapper.tagName () == "forwarded" ?
				wrapper :
				wrapper.firstChildElement ("forwarded");
		if (forwardedElem.isNull ())
			return {};

		const auto& messageElem = forwardedElem.firstChildElement ("message");
		if (messageElem.isNull ())
			return {};

		QXmppMessage original;
#if QXMPP_VERSION >= 0x000800
		original.parse (messageElem.sourceDomElement ());
#else
#warning "You won't have good forwarded messages, Message Archive Management and Message Carbons will look like crap."
		original.parse (XmppElem2DomElem (messageElem));
#endif

		auto delayElem = forwardedElem.firstChildElement ("delay");
		if (!delayElem.isNull ())
		{
			const auto& sourceDT = QXmppUtils::datetimeFromString (delayElem.attribute ("stamp"));
			original.setStamp (sourceDT.toLocalTime ());
		}

		return original;
	}

	EntryStatus PresenceToStatus (const QXmppPresence& pres)
	{
		EntryStatus st (static_cast<State> (pres.availableStatusType () + 1), pres.statusText ());
		if (pres.type () == QXmppPresence::Unavailable)
			st.State_ = SOffline;
		return st;
	}

	QXmppPresence StatusToPresence (State state, const QString& text, int prio)
	{
		QXmppPresence::Type presType = state == SOffline ?
				QXmppPresence::Unavailable :
				QXmppPresence::Available;

		QXmppPresence pres (presType);
		if (state != SOffline && state <= SInvisible)
			pres.setAvailableStatusType (static_cast<QXmppPresence::AvailableStatusType> (state - 1));
		pres.setStatusText (text);
		pres.setPriority (prio);

		return pres;
	}
}
}
}
}
