/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2006-2014  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#pragma once

#include <tuple>
#include <memory>
#include <boost/any.hpp>
#include <QtDebug>
#include <util/sll/oldcppkludges.h>

using Tox = struct Tox;

namespace LeechCraft
{
namespace Azoth
{
namespace Sarin
{
	namespace detail
	{
		template<typename First, typename R, typename... Args>
		std::tuple<Args...> DetectArgsImpl (R (First::*) (Args...));

		template<typename First, typename R, typename... Args>
		std::tuple<Args...> DetectArgsImpl (R (*) (First*, Args...));

		template<typename First, typename F>
		auto DetectArgsImpl (F&& f) -> decltype (DetectArgsImpl<First> (+f));

		template<typename First, typename T>
		using DetectArgs = decltype (DetectArgsImpl<First> (std::declval<T> ()));

		struct RegHolder
		{
			struct Base
			{
				virtual ~Base () = default;

				virtual bool IsEqual (const Base&) const = 0;

				virtual size_t Hash () const = 0;
			};

			std::shared_ptr<Base> Base_;

			template<typename RegType>
			struct Holder final : Base
			{
				const RegType Reg_;

				constexpr Holder (RegType reg)
				: Reg_ { reg }
				{
				}

				bool IsEqual (const Base& otherBase) const override
				{
					const auto other = dynamic_cast<const Holder<RegType>*> (&otherBase);
					if (!other)
						return false;

					return other->Reg_ == Reg_;
				}

				size_t Hash () const override
				{
					return std::hash<RegType> {} (Reg_);
				}
			};

			template<typename RegType>
			RegHolder (RegType reg)
			: Base_ { std::make_shared<Holder<RegType>> (reg) }
			{
			}

			friend bool operator== (const RegHolder& left, const RegHolder& right)
			{
				return left.Base_->IsEqual (*right.Base_);
			}

			friend size_t qHash (const RegHolder& holder)
			{
				return holder.Base_->Hash ();
			}
		};

		struct CBHolder
		{
			boost::any F_;

			template<typename This, typename F, typename Tuple>
			struct Maker;

			template<typename This, typename F, typename... Args>
			struct Maker<This, F, std::tuple<Args...>>
			{
				CBHolder operator() (This pThis, F cb) const
				{
					return
					{
						std::function<void (Args...)> { [pThis, cb] (Args... args) { Util::Invoke (cb, pThis, args...); } }
					};
				}
			};

			template<typename... Args>
			void Invoke (Args... args) const
			{
				const auto res = boost::any_cast<std::function<void (Args...)>> (&F_);
				if (!res)
					qWarning () << Q_FUNC_INFO
							<< "mismatched parameters, expected typeid:"
							<< F_.type ().name ();
				else
					(*res) (args...);
			}
		};
	}

	class CallbackManager
	{
		std::weak_ptr<Tox> Tox_;

		template<auto Reg, typename>
		struct MakeWrapper;

		QHash<detail::RegHolder, QList<detail::CBHolder>> Callbacks_;

		QList<std::function<void (Tox*)>> ProxyReggers_;
	public:
		void SetTox (const std::shared_ptr<Tox>&);

		template<auto Reg, typename F, typename This>
		void Register (This pThis, F callback)
		{
			using Args = detail::DetectArgs<std::remove_pointer_t<This>, F>;

			auto& cbList = Callbacks_ [detail::RegHolder { Reg }];
			cbList.push_back (detail::CBHolder::Maker<This, F, Args> {} (pThis, callback));

			if (cbList.size () == 1)
			{
				auto proxyRegger = [] (Tox *tox) { Reg (tox, MakeWrapper<Reg, Args> {} ()); };
				ProxyReggers_ << proxyRegger;
				if (const auto tox = Tox_.lock ())
					proxyRegger (tox.get ());
			}
		}
	private:
		template<auto Reg, typename... Args>
		void InvokeCallbacks (Args... args)
		{
			const auto& cbList = Callbacks_ [detail::RegHolder { Reg }];
			for (const auto& item : cbList)
				item.Invoke (args...);
		}
	};

	template<auto Reg, typename... Args>
	struct CallbackManager::MakeWrapper<Reg, std::tuple<Args...>>
	{
		auto operator() () const
		{
			return [] (Tox*, Args... args, void *udata)
			{
				auto cbMgr = static_cast<CallbackManager*> (udata);
				cbMgr->InvokeCallbacks<Reg> (args...);
			};
		}
	};
}
}
}
