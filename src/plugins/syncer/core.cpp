/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2006-2013  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include "core.h"
#include <QCoreApplication>
#include <QTimer>
#include <util/util.h>
#include <interfaces/core/icoreproxy.h>
#include <interfaces/core/ipluginsmanager.h>
#include "datastorageserver.h"

namespace LeechCraft
{
namespace Syncer
{
	Core::Core ()
	: DataStorage_ (new DataStorageServer (this))
	, Settings_ (QCoreApplication::organizationName (),
			QCoreApplication::applicationName () + "_Syncer")
	{
		qRegisterMetaType<QList<QByteArray>> ("QList<QByteArray>");

		connect (DataStorage_,
				SIGNAL (gotNewDeltas (const Sync::Deltas_t&, const QByteArray&)),
				this,
				SLOT (handleNewDeltas (const Sync::Deltas_t&, const QByteArray&)));
		connect (DataStorage_,
				SIGNAL (deltasRequired (Sync::Deltas_t*, const QByteArray&)),
				this,
				SLOT (handleDeltasRequired (Sync::Deltas_t*, const QByteArray&)));
		connect (DataStorage_,
				SIGNAL (successfullySentDeltas (quint32, const QByteArray&)),
				this,
				SLOT (handleSuccessfullySentDeltas (quint32, const QByteArray&)));

		connect (DataStorage_,
				SIGNAL (loginError (const QByteArray&)),
				this,
				SLOT (handleLoginError (const QByteArray&)));
		connect (DataStorage_,
				SIGNAL (connectionError (const QByteArray&)),
				this,
				SLOT (handleConnectionError (const QByteArray&)));
		connect (DataStorage_,
				SIGNAL (finishedSuccessfully (quint32, quint32, const QByteArray&)),
				this,
				SLOT (handleFinishedSuccessfully (quint32, quint32, const QByteArray&)));
	}

	Core& Core::Instance ()
	{
		static Core c;
		return c;
	}

	void Core::SetProxy (ICoreProxy_ptr proxy)
	{
		Proxy_ = proxy;
	}

	void Core::SecondInit ()
	{
		QObjectList plugins = Proxy_->GetPluginsManager ()->
				GetAllCastableRoots<ISyncable*> ();
		Q_FOREACH (QObject *plugin, plugins)
			ID2Object_ [qobject_cast<IInfo*> (plugin)->GetUniqueID ()] = plugin;

		QTimer::singleShot (5000, this, SLOT (syncAll ()));
	}

	quint32 Core::GetLastID (const QByteArray& chain) const
	{
		qDebug () << Q_FUNC_INFO << chain;
		Settings_.beginGroup ("IDs");
		quint32 value = Settings_.value (chain, 0).value<quint32> ();
		Settings_.endGroup ();
		return value;
	}

	void Core::SetLastID (const QByteArray& chain, quint32 id)
	{
		qDebug () << Q_FUNC_INFO << chain;
		Settings_.beginGroup ("IDs");
		Settings_.setValue (chain, id);
		Settings_.endGroup ();
	}

	void Core::syncAll ()
	{
		QObjectList plugins = ID2Object_.values ();
		Q_FOREACH (QObject *plugin, ID2Object_.values ())
		{
			QByteArray id = qobject_cast<IInfo*> (plugin)->GetUniqueID ();
			ISyncable *syncable = qobject_cast<ISyncable*> (plugin);
			Sync::ChainIDs_t chains = syncable->AvailableChains ();
			Q_FOREACH (const Sync::ChainID_t& cid, chains)
			{
				QByteArray fullChain = id + "$" + cid;
				DataStorage_->sync (fullChain);
			}
		}
	}

	void Core::handleNewDeltas (const Sync::Deltas_t& deltas, const QByteArray& fullChain)
	{
		QList<QByteArray> parts = fullChain.split ('$');
		QByteArray pluginId = parts.at (0);
		QByteArray chain = parts.at (1);

		if (!ID2Object_.contains (pluginId))
		{
			qWarning () << Q_FUNC_INFO
					<< "unknown plugin ID"
					<< pluginId;
			return;
		}

		ISyncable *syncable = qobject_cast<ISyncable*> (ID2Object_ [pluginId]);

		Sync::Payloads_t payloads;
		Q_FOREACH (const Sync::Delta& delta, deltas)
			payloads << delta.Payload_;

		syncable->ApplyDeltas (payloads, chain);

		SetLastID (fullChain, GetLastID (fullChain) + payloads.size ());
	}

	void Core::handleDeltasRequired (Sync::Deltas_t *deltas, const QByteArray& fullChain)
	{
		const QList<QByteArray>& parts = fullChain.split ('$');
		const QByteArray& pluginId = parts.at (0);
		const QByteArray& chain = parts.at (1);

		if (!ID2Object_.contains (pluginId))
		{
			qWarning () << Q_FUNC_INFO
					<< "unknown plugin ID"
					<< pluginId;
			return;
		}

		ISyncable *syncable = qobject_cast<ISyncable*> (ID2Object_ [pluginId]);

		quint32 id = GetLastID (fullChain);
		Sync::Payloads_t payloads = id ?
				syncable->GetNewDeltas (chain) :
				syncable->GetAllDeltas (chain);
		Q_FOREACH (const Sync::Payload& payload, payloads)
		{
			Sync::Delta delta =
			{
				++id,
				payload
			};

			*deltas << delta;
		}
	}

	void Core::handleSuccessfullySentDeltas (quint32 numDeltas, const QByteArray& fullChain)
	{
		QList<QByteArray> parts = fullChain.split ('$');
		QByteArray pluginId = parts.at (0);
		QByteArray chain = parts.at (1);

		if (!ID2Object_.contains (pluginId))
		{
			qWarning () << Q_FUNC_INFO
					<< "unknown plugin ID"
					<< pluginId;
			return;
		}

		ISyncable *syncable = qobject_cast<ISyncable*> (ID2Object_ [pluginId]);

		syncable->PurgeNewDeltas (chain, numDeltas);
		SetLastID (fullChain, GetLastID (fullChain) + numDeltas);
	}

	void Core::handleLoginError (const QByteArray& chain)
	{
		QString name = GetNameForChain (chain);
		if (name.isEmpty ())
		{
			qWarning () << Q_FUNC_INFO
					<< "^^^^^^^^^^^^";
			return;
		}

		emit gotEntity (Util::MakeNotification (tr ("Sync failure"),
				tr ("Login error when synchronizing plugin %1.")
					.arg (name),
				PCritical_));
	}

	void Core::handleConnectionError (const QByteArray& chain)
	{
		QString name = GetNameForChain (chain);
		if (name.isEmpty ())
		{
			qWarning () << Q_FUNC_INFO
					<< "^^^^^^^^^^^^";
			return;
		}

		emit gotEntity (Util::MakeNotification (tr ("Sync failure"),
				tr ("Connection error when synchronizing plugin %1.")
					.arg (name),
				PCritical_));
	}

	void Core::handleFinishedSuccessfully (quint32 sent, quint32 received, const QByteArray& chain)
	{
		QString name = GetNameForChain (chain);
		if (name.isEmpty ())
		{
			qWarning () << Q_FUNC_INFO
					<< "^^^^^^^^^^^^";
			return;
		}

		if (sent + received)
		{
			QString text = tr ("Successfully synchronized plugin %1")
					.arg (GetNameForChain (chain));
			text += ": ";
			text += tr ("%n item(s) received", 0, received);
			text += ", ";
			text += tr ("%n item(s) sent", 0, received);
			emit gotEntity (Util::MakeNotification (tr ("Sync"),
					text,
					PInfo_));
		}
	}

	QString Core::GetNameForChain (const QByteArray& fullChain)
	{
		QList<QByteArray> parts = fullChain.split ('$');
		QByteArray pluginId = parts.at (0);

		if (!ID2Object_.contains (pluginId))
		{
			qWarning () << Q_FUNC_INFO
					<< "unknown plugin ID"
					<< pluginId;
			return QString ();
		}

		return qobject_cast<IInfo*> (ID2Object_ [pluginId])->GetName ();
	}
}
}
