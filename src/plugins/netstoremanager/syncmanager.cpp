/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2010-2012  Oleg Linkin
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include "syncmanager.h"
#include <QtDebug>
#include "accountsmanager.h"
#include "syncer.h"
#if defined (Q_OS_LINUX)
	#include "fileswatcher_inotify.h"
#include "syncwidget.h"
#elif defined(Q_OS_WIN32)
	#include "fileswatcher_dummy.h"
#endif

namespace LeechCraft
{
namespace NetStoreManager
{
	SyncManager::SyncManager (AccountsManager *am, QObject *parent)
	: QObject (parent)
	, AM_ (am)
	{
#if defined (Q_OS_LINUX)
		FilesWatcher_ = new FilesWatcherInotify (this);
#else
		FilesWatcher_ = new FilesWatcherDummy (this);
#endif

		connect (FilesWatcher_,
				SIGNAL (dirWasCreated (QString)),
				this,
				SLOT (handleDirWasCreated (QString)));
		connect (FilesWatcher_,
				SIGNAL (dirWasRemoved (QString)),
				this,
				SLOT (handleDirWasRemoved (QString)));
		connect (FilesWatcher_,
				SIGNAL (fileWasCreated (QString)),
				this,
				SLOT (handleFileWasCreated (QString)));
		connect (FilesWatcher_,
				SIGNAL (fileWasRemoved (QString)),
				this,
				SLOT (handleFileWasRemoved (QString)));
		connect (FilesWatcher_,
				SIGNAL (fileWasUpdated (QString)),
				this,
				SLOT (handleFileWasUpdated (QString)));
		connect (FilesWatcher_,
				SIGNAL (entryWasMoved (QString, QString)),
				this,
				SLOT (handleEntryWasMoved (QString, QString)));
		connect (FilesWatcher_,
				SIGNAL (entryWasRenamed (QString, QString)),
				this,
				SLOT (handleEntryWasRenamed (QString, QString)));

		for (auto account : AM_->GetAccounts ())
		{
			auto isfl = qobject_cast<ISupportFileListings*> (account->GetQObject ());
			if (!isfl)
				continue;
			connect (account->GetQObject (),
					SIGNAL (gotListing (QList<StorageItem>)),
					this,
					SLOT (handleGotListing (QList<StorageItem>)));
			connect (account->GetQObject (),
					SIGNAL (gotNewItem (StorageItem, QByteArray)),
					this,
					SLOT (handleGotNewItem (StorageItem, QByteArray)));
		}
	}

	void SyncManager::Release ()
	{
	}

	void SyncManager::handleDirectoriesToSyncUpdated (const QVariantMap& map)
	{
		QStringList paths;
		for (const auto& key : map.keys ())
		{
			const auto& pair = map [key].value<SyncDirs_t> ();
			paths << pair.first;
			qDebug () << key << pair;
			if (AccountID2Syncer_.contains (key))
			{
				if (AccountID2Syncer_ [key]->GetLocalPath () == pair.first &&
						AccountID2Syncer_ [key]->GetRemotePath () == pair.second)
					continue;
				else
				{
					AccountID2Syncer_ [key]->stop ();
					AccountID2Syncer_.take (key)->deleteLater ();
				}
			}
			auto acc = AM_->GetAccountFromUniqueID (key);
			AccountID2Syncer_ [key] = CreateSyncer (acc, pair.first, pair.second);
			if (auto isfl = qobject_cast<ISupportFileListings*> (acc->GetQObject ()))
				isfl->RefreshListing ();
		}

		FilesWatcher_->updatePaths (paths);
	}

	Syncer* SyncManager::CreateSyncer (IStorageAccount *isa,
			const QString& baseDir, const QString& remoteDir)
	{
		Syncer *syncer = new Syncer (baseDir, remoteDir, isa, this);
		return syncer;
	}

	void SyncManager::handleDirWasCreated (const QString& path)
	{
		for (auto syncer : AccountID2Syncer_.values ())
			if (path.startsWith (syncer->GetLocalPath ()))
				syncer->dirWasCreated (path);
	}

	void SyncManager::handleDirWasRemoved (const QString& path)
	{
		for (auto syncer : AccountID2Syncer_.values ())
			if (path.startsWith (syncer->GetLocalPath ()))
				syncer->dirWasRemoved (path);
	}

	void SyncManager::handleFileWasCreated (const QString& path)
	{
		for (auto syncer : AccountID2Syncer_.values ())
			if (path.startsWith (syncer->GetLocalPath ()))
				syncer->fileWasCreated (path);
	}

	void SyncManager::handleFileWasRemoved (const QString& path)
	{
		for (auto syncer : AccountID2Syncer_.values ())
			if (path.startsWith (syncer->GetLocalPath ()))
				syncer->fileWasRemoved (path);
	}

	void SyncManager::handleFileWasUpdated (const QString& path)
	{
		for (auto syncer : AccountID2Syncer_.values ())
			if (path.startsWith (syncer->GetLocalPath ()))
				syncer->fileWasUpdated (path);
	}

	void SyncManager::handleEntryWasMoved (const QString& oldPath,
			const QString& newPath)
	{
		qDebug () << Q_FUNC_INFO << oldPath << newPath;
	}

	void SyncManager::handleEntryWasRenamed (const QString& oldName,
			const QString& newName)
	{
		qDebug () << Q_FUNC_INFO << oldName << newName;
	}

	void SyncManager::handleGotListing (const QList<StorageItem>& items)
	{
		qDebug () << Q_FUNC_INFO;
		auto isa = qobject_cast<IStorageAccount*> (sender ());
		if (!isa)
			return;
		for (auto accountId : AccountID2Syncer_.keys ())
		{
			if (isa->GetUniqueID () == accountId)
			{
				AccountID2Syncer_ [accountId]->SetItems (items);
				if (!AccountID2Syncer_ [accountId]->IsStarted ())
					AccountID2Syncer_ [accountId]->start ();
			}
		}
	}

	void SyncManager::handleGotNewItem (const StorageItem& item,
			const QByteArray& parentId)
	{
		auto isa = qobject_cast<IStorageAccount*> (sender ());
		if (!isa)
			return;

		for (auto accountId : AccountID2Syncer_.keys ())
			if (isa->GetUniqueID () == accountId)
				AccountID2Syncer_ [accountId]->AddNewItem (item, parentId);
	}

}
}

