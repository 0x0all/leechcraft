/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2010-2013  Oleg Linkin <MaledictusDeMagog@gmail.com>
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include "drivemanager.h"
#include <QNetworkRequest>
#include <QtDebug>
#include <QFileInfo>
#include <QDesktopServices>
#include <QMessageBox>
#include <QMainWindow>
#include <interfaces/core/irootwindowsmanager.h>
#include <util/util.h>
#include <qjson/parser.h>
#include <qjson/serializer.h>
#include "account.h"
#include "core.h"
#include "xmlsettingsmanager.h"

namespace LeechCraft
{
namespace NetStoreManager
{
namespace DBox
{
	DriveManager::DriveManager (Account *acc, QObject *parent)
	: QObject (parent)
	, DirectoryId_ ("application/vnd.google-apps.folder")
	, Account_ (acc)
	, SecondRequestIfNoItems_ (true)
	{
	}

	void DriveManager::RequestUserId ()
	{
		auto guard = MakeRunnerGuard ();
		ApiCallQueue_ << [this] (const QString&) { RequestAccountInfo (); };
	}

	void DriveManager::RefreshListing (const QByteArray& parentId)
	{
		auto guard = MakeRunnerGuard ();
		ApiCallQueue_ << [this, parentId] (const QString&) { RequestFiles (parentId); };
	}

	void DriveManager::ShareEntry (const QString& id, ShareType type)
	{
		if (id.isEmpty ())
			return;
		auto guard = MakeRunnerGuard ();
		ApiCallQueue_ << [this, id, type] (const QString&) { RequestSharingEntry (id, type); };
	}

	void DriveManager::CreateDirectory (const QString& name,
			const QString& parentId)
	{
		auto guard = MakeRunnerGuard ();
		ApiCallQueue_ << [this, name, parentId] (const QString&)
				{ RequestCreateDirectory (name, parentId); };
	}

	void DriveManager::RemoveEntry (const QByteArray& id)
	{
		if (id.isEmpty ())
			return;
		ApiCallQueue_ << [this, id] (const QString& key) { RequestEntryRemoving (id, key); };
		RequestAccessToken ();
	}

	void DriveManager::MoveEntryToTrash (const QByteArray& id)
	{
		if (id.isEmpty ())
			return;
		ApiCallQueue_ << [this, id] (const QString& key) { RequestMovingEntryToTrash (id, key); };
		RequestAccessToken ();
	}

	void DriveManager::RestoreEntryFromTrash (const QByteArray& id)
	{
		if (id.isEmpty ())
			return;
		ApiCallQueue_ << [this, id] (const QString& key) { RequestRestoreEntryFromTrash (id, key); };
		RequestAccessToken ();
	}

	void DriveManager::Copy (const QByteArray& id, const QString& parentId)
	{
		if (id.isEmpty ())
			return;
		ApiCallQueue_ << [this, id, parentId] (const QString& key) { RequestCopyItem (id, parentId, key); };
		RequestAccessToken ();
	}

	void DriveManager::Move (const QByteArray& id, const QString& parentId)
	{
		if (id.isEmpty ())
			return;
		ApiCallQueue_ << [this, id, parentId] (const QString& key) { RequestMoveItem (id, parentId, key); };
		RequestAccessToken ();
	}

	void DriveManager::Upload (const QString& filePath, const QStringList& parentId)
	{
		QString parent = parentId.value (0);
		ApiCallQueue_ << [this, filePath, parent] (const QString& key) { RequestUpload (filePath, parent, key); };
		RequestAccessToken ();
	}

	void DriveManager::Download (const QString& id, const QString& filepath,
			TaskParameters tp, bool silent, bool open)
	{
		if (id.isEmpty ())
			return;
		ApiCallQueue_ << [this, id] (const QString& key) { RequestFileInfo (id, key); };
		DownloadsQueue_ << [this, filepath, tp, silent, open] (const QUrl& url)
			{ DownloadFile (filepath, url, tp, silent, open); };
		RequestAccessToken ();
	}

	void DriveManager::Rename (const QString& id, const QString& newName)
	{
		if (id.isEmpty ())
			return;
		ApiCallQueue_ << [this, id, newName] (const QString& key) { RequestRenameItem (id, newName, key); };
		RequestAccessToken ();
	}

	void DriveManager::RequestFileChanges (qlonglong startId, const QString& pageToken)
	{
		ApiCallQueue_ << [this, startId, pageToken] (const QString& key)
				{ GetFileChanges (startId, pageToken, key); };
		RequestAccessToken ();
	}

	std::shared_ptr< void > DriveManager::MakeRunnerGuard ()
	{
		const bool shouldRun = ApiCallQueue_.isEmpty ();
		return std::shared_ptr<void> (nullptr, [this, shouldRun] (void*)
			{
				if (shouldRun)
					ApiCallQueue_.dequeue () (QString ());
			});
	}

	void DriveManager::RequestAccountInfo ()
	{
		if (Account_->GetAccessToken ().isEmpty ())
			return;

		QString str = QString ("https://api.dropbox.com/1/account/info?access_token=%1")
				.arg (Account_->GetAccessToken ());
		QNetworkRequest request (str);
		request.setHeader (QNetworkRequest::ContentTypeHeader,
				"application/x-www-form-urlencoded");
		QNetworkReply *reply = Core::Instance ().GetProxy ()->
				GetNetworkAccessManager ()->get (request);
		connect (reply,
				SIGNAL (finished ()),
				this,
				SLOT (handleGotAccountInfo ()));
	}

	void DriveManager::RequestFiles (const QByteArray& parentId)
	{
		if (Account_->GetAccessToken ().isEmpty ())
			return;

		QString str = QString ("https://api.dropbox.com/1/metadata/dropbox?access_token=%1&path=%2")
				.arg (Account_->GetAccessToken ())
				.arg (parentId.isEmpty () ? "/" : QString::fromUtf8 (parentId));
		QNetworkRequest request (str);

		request.setHeader (QNetworkRequest::ContentTypeHeader,
				"application/x-www-form-urlencoded");

		QNetworkReply *reply = Core::Instance ().GetProxy ()->
				GetNetworkAccessManager ()->get (request);

		connect (reply,
				SIGNAL (finished ()),
				this,
				SLOT (handleGotFiles ()));
	}

	void DriveManager::RequestSharingEntry (const QString& id, ShareType type)
	{

		QString str;
		switch (type)
		{
		case ShareType::Preview:
			str = QString ("https://api.dropbox.com/1/media/dropbox/%1?access_token=%2")
					.arg (id)
					.arg (Account_->GetAccessToken ());
			break;
		case ShareType::Share:
			str = QString ("https://api.dropbox.com/1/shares/dropbox/%1?access_token=%2")
					.arg (id)
					.arg (Account_->GetAccessToken ());
			break;
		}

		QNetworkRequest request (str);
		request.setHeader (QNetworkRequest::ContentTypeHeader, "application/json");

		QNetworkReply *reply = Core::Instance ().GetProxy ()->
				GetNetworkAccessManager ()->post (request, QByteArray ());

		connect (reply,
				SIGNAL (finished ()),
				this,
				SLOT (handleRequestFileSharing ()));
	}

	void DriveManager::RequestCreateDirectory (const QString& name, const QString& parentId)
	{
		QString str = QString ("https://api.dropbox.com/1/fileops/create_folder?access_token=%1&root=%2&path=%3")
				.arg (Account_->GetAccessToken ())
				.arg ("dropbox")
				.arg (parentId + "/" + name);

		QNetworkRequest request (str);
		request.setHeader (QNetworkRequest::ContentTypeHeader, "application/json");
		QNetworkReply *reply = Core::Instance ().GetProxy ()->GetNetworkAccessManager ()->
				post (request, QByteArray ());
		connect (reply,
				SIGNAL (finished ()),
				this,
				SLOT (handleCreateDirectory ()));
	}

	void DriveManager::RequestEntryRemoving (const QString& id,
			const QString& key)
	{
		QString str = QString ("https://www.googleapis.com/drive/v2/files/%1?access_token=%2")
				.arg (id, key);
		QNetworkRequest request (str);
		request.setHeader (QNetworkRequest::ContentTypeHeader, "application/json");

		QNetworkReply *reply = Core::Instance ().GetProxy ()->
				GetNetworkAccessManager ()->deleteResource (request);

		connect (reply,
				SIGNAL (finished ()),
				this,
				SLOT (handleRequestEntryRemoving ()));
	}

	void DriveManager::RequestMovingEntryToTrash (const QString& id,
			const QString& key)
	{
		QString str = QString ("https://www.googleapis.com/drive/v2/files/%1/trash?access_token=%2")
				.arg (id, key);
		QNetworkRequest request (str);
		request.setHeader (QNetworkRequest::ContentTypeHeader, "application/json");

		QNetworkReply *reply = Core::Instance ().GetProxy ()->
				GetNetworkAccessManager ()->post (request, QByteArray ());

		connect (reply,
				SIGNAL (finished ()),
				this,
				SLOT (handleRequestMovingEntryToTrash ()));
	}

	void DriveManager::RequestRestoreEntryFromTrash (const QString& id,
			const QString& key)
	{
		QString str = QString ("https://www.googleapis.com/drive/v2/files/%1/untrash?access_token=%2")
				.arg (id, key);
		QNetworkRequest request (str);
		request.setHeader (QNetworkRequest::ContentTypeHeader, "application/json");

		QNetworkReply *reply = Core::Instance ().GetProxy ()->
				GetNetworkAccessManager ()->post (request, QByteArray ());

		connect (reply,
				SIGNAL (finished ()),
				this,
				SLOT (handleRequestRestoreEntryFromTrash ()));
	}

	void DriveManager::RequestAccessToken ()
	{
// 		QNetworkRequest request (QUrl ("https://accounts.google.com/o/oauth2/token"));
// 		QString str = QString ("refresh_token=%1&client_id=%2&client_secret=%3&grant_type=%4")
// 				.arg (Account_->GetRefreshToken ())
// 				.arg ("844868161425.apps.googleusercontent.com")
// 				.arg ("l09HkM6nbPMEYcMdcdeGBdaV")
// 				.arg ("refresh_token");
//
// 		request.setHeader (QNetworkRequest::ContentTypeHeader, "application/x-www-form-urlencoded");
//
// 		QNetworkReply *reply = Core::Instance ().GetProxy ()->
// 				GetNetworkAccessManager ()->post (request, str.toUtf8 ());
//
// 		connect (reply,
// 				SIGNAL (finished ()),
// 				this,
// 				SLOT (handleAuthTokenRequestFinished ()));
	}

	void DriveManager::RequestUpload (const QString& filePath,
			const QString& parent, const QString& key)
	{
		emit uploadStatusChanged (tr ("Initializing..."), filePath);

		QFileInfo info (filePath);
		const QUrl initiateUrl (QString ("https://www.googleapis.com/upload/drive/v2/files?access_token=%1&uploadType=resumable")
				.arg (key));
		QNetworkRequest request (initiateUrl);
		request.setPriority (QNetworkRequest::LowPriority);
#ifdef HAVE_MAGIC
		request.setRawHeader ("X-Upload-Content-Type",
				magic_file (Magic_, filePath.toUtf8 ()));
#endif
		request.setRawHeader ("X-Upload-Content-Length",
				QString::number (QFileInfo (filePath).size ()).toUtf8 ());
		QVariantMap map;
		map ["title"] = QFileInfo (filePath).fileName ();
		if (!parent.isEmpty ())
		{
			QVariantList parents;
			QVariantMap parentMap;
			parentMap ["id"] = parent;
			parents << parentMap;
			map ["parents"] = parents;
		}

		const auto& data = QJson::Serializer ().serialize (map);
		request.setHeader (QNetworkRequest::ContentTypeHeader, "application/json");
		request.setHeader (QNetworkRequest::ContentLengthHeader, data.size ());

		QNetworkReply *reply = Core::Instance ().GetProxy ()->
				GetNetworkAccessManager ()->post (request, data);
		Reply2FilePath_ [reply] = filePath;

		connect (reply,
				SIGNAL (finished ()),
				this,
				SLOT (handleUploadRequestFinished ()));
	}

	void DriveManager::RequestCopyItem (const QString& id,
			const QString& parentId, const QString& key)
	{
		QString str = QString ("https://www.googleapis.com/drive/v2/files/%1/copy?access_token=%2")
				.arg (id)
				.arg (key);

		QNetworkRequest request (str);
		request.setHeader (QNetworkRequest::ContentTypeHeader, "application/json");
		QVariantMap data;
		if (!parentId.isEmpty ())
		{
			QVariantList parents;
			QVariantMap parent;
			parent ["id"] = parentId;
			parents << parent;
			data ["parents"] = parents;
		}

		QNetworkReply *reply = Core::Instance ().GetProxy ()->GetNetworkAccessManager ()->
				post (request, QJson::Serializer ().serialize (data));
		connect (reply,
				SIGNAL (finished ()),
				this,
				SLOT (handleCopyItem ()));
	}

	void DriveManager::RequestMoveItem (const QString& id,
			const QString& parentId, const QString& key)
	{
		QString str = QString ("https://www.googleapis.com/drive/v2/files/%1?access_token=%2")
				.arg (id)
				.arg (key);

		QNetworkRequest request (str);
		request.setHeader (QNetworkRequest::ContentTypeHeader, "application/json");
		QVariantMap data;
		if (!parentId.isEmpty ())
		{
			QVariantList parents;
			QVariantMap parent;
			parent ["id"] = parentId;
			parents << parent;
			data ["parents"] = parents;
		}

		QNetworkReply *reply = Core::Instance ().GetProxy ()->GetNetworkAccessManager ()->
				put (request, QJson::Serializer ().serialize (data));
		connect (reply,
				SIGNAL (finished ()),
				this,
				SLOT (handleMoveItem ()));
	}

	void DriveManager::GetFileChanges (qlonglong startId,
			const QString& pageToken, const QString& key)
	{
		QString urlSuffix = "includeDeleted=true&access_token=" + key;

		if (startId)
		{
			urlSuffix.append ("&startChangeId=");
			urlSuffix += QString::number (startId);
		}

		if (!pageToken.isEmpty ())
		{
			urlSuffix.append ("&pageToken=");
			urlSuffix += pageToken;
		}

		const QString str = "https://www.googleapis.com/drive/v2/changes?" + urlSuffix;

		QNetworkReply *reply = Core::Instance ().GetProxy ()->GetNetworkAccessManager ()->
				get (QNetworkRequest (str));
		connect (reply,
				SIGNAL (finished ()),
				this,
				SLOT (handleGetFileChanges ()));
	}

	void DriveManager::RequestFileInfo (const QString& id, const QString& key)
	{
		QString str = QString ("https://www.googleapis.com/drive/v2/files/%1?access_token=%2")
				.arg (id)
				.arg (key);

		QNetworkReply *reply = Core::Instance ().GetProxy ()->GetNetworkAccessManager ()->
				get (QNetworkRequest (str));
		Reply2DownloadAccessToken_ [reply] = key;
		connect (reply,
				SIGNAL (finished ()),
				this,
				SLOT (handleGetFileInfo ()));
	}

	void DriveManager::RequestRenameItem (const QString& id, const QString& name, const QString& key)
	{
		QString str = QString ("https://www.googleapis.com/drive/v2/files/%1?access_token=%2")
				.arg (id)
				.arg (key);

		QNetworkRequest request (str);
		request.setHeader (QNetworkRequest::ContentTypeHeader, "application/json");
		QVariantMap data;
		data ["title"] = name;
		QNetworkReply *reply = Core::Instance ().GetProxy ()->GetNetworkAccessManager ()->
				put (request, QJson::Serializer ().serialize (data));
		Reply2DownloadAccessToken_ [reply] = key;
		connect (reply,
				SIGNAL (finished ()),
				this,
				SLOT (handleItemRenamed ()));
	}

	void DriveManager::DownloadFile (const QString& filePath, const QUrl& url,
			TaskParameters tp, bool silent, bool open)
	{
		QString savePath;
		if (silent)
			savePath = QDesktopServices::storageLocation (QDesktopServices::TempLocation) +
					"/" + QFileInfo (filePath).fileName ();

		auto e = Util::MakeEntity (url, savePath, tp);
		QFileInfo fi (filePath);
		e.Additional_ ["Filename"] = QString ("%1_%2.%3")
				.arg (fi.baseName ())
				.arg (QDateTime::currentDateTime ().toTime_t ())
				.arg (fi.completeSuffix ());
		silent ?
			Core::Instance ().DelegateEntity (e, filePath, open) :
			Core::Instance ().SendEntity (e);
	}

	void DriveManager::FindSyncableItems (const QStringList&,
			const QString& baseDir, const QList<DBoxItem>& items)
	{
	}

	void DriveManager::ParseError (const QVariantMap& map)
	{
		const auto& errorMap = map ["error"].toMap ();
		const QString& code = errorMap ["code"].toString ();
		QString msg = errorMap ["message"].toString ();

		Q_UNUSED (code)
		//TODO fix false execute
// 		if (code == "500")
// 			msg = tr ("Google Drive API v.2 doesn't support directory copying.");
		Core::Instance ().SendEntity (Util::MakeNotification ("NetStoreManager",
				msg,
				PWarning_));
	}

	void DriveManager::handleGotAccountInfo ()
	{
		QNetworkReply *reply = qobject_cast<QNetworkReply*> (sender ());
		if (!reply)
			return;
		reply->deleteLater ();

		bool ok = false;
		const auto& res = QJson::Parser ().parse (reply->readAll (), &ok);
		if (!ok)
		{
			qDebug () << Q_FUNC_INFO
					<< "parse error";
			return;
		}

		Account_->SetUserID (res.toMap () ["uid"].toString ());
	}

	namespace
	{
		DBoxItem CreateDBoxItem (const QVariant& itemData)
		{
			const QVariantMap& map = itemData.toMap ();

			DBoxItem driveItem;
			driveItem.FileSize_ = map ["bytes"].toULongLong ();
			driveItem.FolderHash_ = map ["hash"].toString ();
			driveItem.Revision_ = map ["rev"].toByteArray ();
			const auto& path = map ["path"].toString ();
			driveItem.Id_ = path;
			driveItem.ParentID_ = QFileInfo (path).dir ().absolutePath ();
			driveItem.IsDeleted_ = map ["is_deleted"].toBool ();
			driveItem.IsFolder_ = map ["is_dir"].toBool ();
			driveItem.ModifiedDate_ = map ["modified"].toDateTime ();
			driveItem.Name_ = QFileInfo (path).fileName ();
			driveItem.MimeType_ = map ["mime_type"].toString ().replace ('/', '-');

			return driveItem;
		}
	}

	void DriveManager::handleGotFiles ()
	{
		QNetworkReply *reply = qobject_cast<QNetworkReply*> (sender ());
		if (!reply)
			return;

		reply->deleteLater ();

		bool ok = false;
		const auto& res = QJson::Parser ().parse (reply->readAll (), &ok);

		if (!ok)
		{
			qDebug () << Q_FUNC_INFO << "parse error";
			return;
		}

		const auto& resMap = res.toMap ();
		if (!resMap.contains ("contents"))
		{
			qDebug () << Q_FUNC_INFO << "there are no items";
			if (SecondRequestIfNoItems_)
			{
				SecondRequestIfNoItems_ = false;
				RefreshListing ();
			}
			return;
		}

		SecondRequestIfNoItems_ = true;
		QList<DBoxItem> resList;
		Q_FOREACH (const auto& item, resMap ["contents"].toList ())
		{
			const auto& driveItem = CreateDBoxItem (item);

			if (driveItem.Name_.isEmpty ())
				continue;
			resList << driveItem;
		}

		emit gotFiles (resList);
	}

	void DriveManager::handleRequestFileSharing ()
	{
		QNetworkReply *reply = qobject_cast<QNetworkReply*> (sender ());
		if (!reply)
			return;

		reply->deleteLater ();

		bool ok = false;
		const auto& res = QJson::Parser ().parse (reply->readAll (), &ok);

		if (!ok)
		{
			qDebug () << Q_FUNC_INFO
					<< "parse error";
			return;
		}

		const auto& map = res.toMap ();
		qDebug () << Q_FUNC_INFO
				<< "file shared successfully";
		emit gotSharedFileUrl (map ["url"].toUrl (), map ["expires"].toDateTime ());
	}

	void DriveManager::handleCreateDirectory ()
	{
		QNetworkReply *reply = qobject_cast<QNetworkReply*> (sender ());
		if (!reply)
			return;
		reply->deleteLater ();

		bool ok = false;
		const auto& res = QJson::Parser ().parse (reply->readAll (), &ok);
		if (!ok)
		{
			qDebug () << Q_FUNC_INFO
					<< "parse error";
			return;
		}

		qDebug () << Q_FUNC_INFO
				<< "directory created successfully";
		emit gotNewItem (CreateDBoxItem (res.toMap ()));
	}

	void DriveManager::handleRequestEntryRemoving ()
	{
		QNetworkReply *reply = qobject_cast<QNetworkReply*> (sender ());
		if (!reply)
			return;

		reply->deleteLater ();

		bool ok = false;
		const auto& res = QJson::Parser ().parse (reply->readAll (), &ok);
		if (!ok)
		{
			qDebug () << Q_FUNC_INFO
					<< "parse error";
			return;
		}

		if (!res.toMap ().contains ("error"))
		{
			qDebug () << Q_FUNC_INFO
					<< "file removed successfully";
// 			RefreshListing ();
			return;
		}

		ParseError (res.toMap ());
	}

	void DriveManager::handleRequestMovingEntryToTrash ()
	{
		QNetworkReply *reply = qobject_cast<QNetworkReply*> (sender ());
		if (!reply)
			return;

		reply->deleteLater ();

		bool ok = false;
		const auto& res = QJson::Parser ().parse (reply->readAll (), &ok);
		if (!ok)
		{
			qDebug () << Q_FUNC_INFO
					<< "parse error";
			return;
		}

		if (!res.toMap ().contains ("error"))
		{
			qDebug () << Q_FUNC_INFO
					<< "file moved to trash successfully";
			RequestFileChanges (XmlSettingsManager::Instance ().Property ("largestChangeId", 0)
					.toLongLong ());
			return;
		}

		ParseError (res.toMap ());
	}

	void DriveManager::handleRequestRestoreEntryFromTrash ()
	{
		QNetworkReply *reply = qobject_cast<QNetworkReply*> (sender ());
		if (!reply)
			return;

		reply->deleteLater ();

		bool ok = false;
		const auto& res = QJson::Parser ().parse (reply->readAll (), &ok);
		if (!ok)
		{
			qDebug () << Q_FUNC_INFO
					<< "parse error";
			return;
		}

		if (!res.toMap ().contains ("error"))
		{
			qDebug () << Q_FUNC_INFO
					<< "file restored from trash successfully";
			RequestFileChanges (XmlSettingsManager::Instance ().Property ("largestChangeId", 0)
					.toLongLong ());
			return;
		}

		ParseError (res.toMap ());
	}

	void DriveManager::handleUploadRequestFinished ()
	{
		QNetworkReply *reply = qobject_cast<QNetworkReply*> (sender ());
		if (!reply)
			return;

		reply->deleteLater ();
		QString path = Reply2FilePath_.take (reply);

		const int code = reply->
				attribute (QNetworkRequest::HttpStatusCodeAttribute).toInt ();
		if (code != 200)
		{
			qWarning () << Q_FUNC_INFO
					<< "upload initiating failed with code:"
					<< code;
			return;
		}

		emit uploadStatusChanged (tr ("Uploading..."), path);

		QFile *file = new QFile (path);
		if (!file->open (QIODevice::ReadOnly))
		{
			qWarning () << Q_FUNC_INFO
					<< "unable to open file: "
					<< file->errorString ();
			return;
		}

		QUrl url (reply->rawHeader ("Location"));
		QNetworkRequest request (url);
#ifdef HAVE_MAGIC
		request.setHeader (QNetworkRequest::ContentTypeHeader,
				magic_file (Magic_, path.toUtf8 ()));
#endif
		request.setHeader (QNetworkRequest::ContentLengthHeader,
				QString::number (QFileInfo (path).size ()).toUtf8 ());

		QNetworkReply *uploadReply = Core::Instance ().GetProxy ()->
				GetNetworkAccessManager ()->put (request, file);
		file->setParent (uploadReply);
		Reply2FilePath_ [uploadReply] = path;

		connect (uploadReply,
				SIGNAL (finished ()),
				this,
				SLOT (handleUploadFinished ()));
		connect (uploadReply,
				SIGNAL (error (QNetworkReply::NetworkError)),
				this,
				SLOT (handleUploadError (QNetworkReply::NetworkError)));
		connect (uploadReply,
				SIGNAL (uploadProgress (qint64, qint64)),
				this,
				SLOT (handleUploadProgress (qint64, qint64)));
	}

	void DriveManager::handleUploadFinished ()
	{
		QNetworkReply *reply = qobject_cast<QNetworkReply*> (sender ());
		if (!reply)
			return;

		reply->deleteLater ();

		bool ok = false;
		const auto& res = QJson::Parser ().parse (reply->readAll (), &ok);
		if (!ok)
		{
			qDebug () << Q_FUNC_INFO
					<< "parse error";
			return;
		}

		const auto& map = res.toMap ();
		const auto& id = map ["id"].toString ();

		if (!map.contains ("error"))
		{
			qDebug () << Q_FUNC_INFO
					<< "file uploaded successfully";
			RequestFileChanges (XmlSettingsManager::Instance ().Property ("largestChangeId", 0)
					.toLongLong ());
			emit finished (id, Reply2FilePath_.take (reply));
			return;
		}

		 ParseError (map);
	}

	void DriveManager::handleUploadProgress (qint64 uploaded, qint64 total)
	{
		QNetworkReply *reply = qobject_cast<QNetworkReply*> (sender ());
		if (!reply)
			return;

		emit uploadProgress (uploaded, total, Reply2FilePath_ [reply]);
	}

	void DriveManager::handleUploadError (QNetworkReply::NetworkError error)
	{
		QNetworkReply *reply = qobject_cast<QNetworkReply*> (sender ());
		if (!reply)
			return;

		reply->deleteLater ();

		emit uploadError ("Error", Reply2FilePath_.take (reply));
		if (error == QNetworkReply::ProtocolUnknownError)
		{
			//TODO resume upload
		}
	}

	void DriveManager::handleCopyItem ()
	{
		QNetworkReply *reply = qobject_cast<QNetworkReply*> (sender ());
		if (!reply)
			return;

		reply->deleteLater ();

		bool ok = false;
		const auto& res = QJson::Parser ().parse (reply->readAll (), &ok);
		if (!ok)
		{
			qDebug () << Q_FUNC_INFO
					<< "parse error";
			return;
		}

		if (!res.toMap ().contains ("error"))
		{
			qDebug () << Q_FUNC_INFO
					<< "entry copied successfully";
			RequestFileChanges (XmlSettingsManager::Instance ().Property ("largestChangeId", 0)
					.toLongLong ());
			return;
		}

		ParseError (res.toMap ());
	}

	void DriveManager::handleMoveItem ()
	{
		QNetworkReply *reply = qobject_cast<QNetworkReply*> (sender ());
		if (!reply)
			return;

		reply->deleteLater ();

		bool ok = false;
		const auto& res = QJson::Parser ().parse (reply->readAll (), &ok);
		if (!ok)
		{
			qDebug () << Q_FUNC_INFO
					<< "parse error";
			return;
		}

		if (!res.toMap ().contains ("error"))
		{
			qDebug () << Q_FUNC_INFO
					<< "entry moved successfully";
			RequestFileChanges (XmlSettingsManager::Instance ().Property ("largestChangeId", 0)
					.toLongLong ());
			return;
		}

		ParseError (res.toMap ());
	}

	void DriveManager::handleGetFileChanges ()
	{
	}

	void DriveManager::handleGetFileInfo ()
	{
		QNetworkReply *reply = qobject_cast<QNetworkReply*> (sender ());
		if (!reply)
			return;

		reply->deleteLater ();

		bool ok = false;
		const auto& res = QJson::Parser ().parse (reply->readAll (), &ok);
		if (!ok)
		{
			qDebug () << Q_FUNC_INFO
					<< "parse error";
			return;
		}

		const QVariantMap& map = res.toMap ();
		qDebug () << map;

		ParseError (map);
	}

	void DriveManager::handleItemRenamed ()
	{
		QNetworkReply *reply = qobject_cast<QNetworkReply*> (sender ());
		if (!reply)
			return;

		reply->deleteLater ();

		bool ok = false;
		const auto& res = QJson::Parser ().parse (reply->readAll (), &ok);
		if (!ok)
		{
			qDebug () << Q_FUNC_INFO
					<< "parse error";
			return;
		}

		const QVariantMap& map = res.toMap ();

		if (!map.contains ("error"))
		{
			DBoxItem it = CreateDBoxItem (res);
			qDebug () << Q_FUNC_INFO
					<< "entry renamed successfully";
			RequestFileChanges (XmlSettingsManager::Instance ().Property ("largestChangeId", 0)
					.toLongLong ());

			return;
		}

		ParseError (map);
	}

}
}
}

