/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2013  Slava Barinov <rayslava@gmail.com>
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include "tweet.h"

namespace LeechCraft
{
namespace Woodpecker
{

Tweet::Tweet (QObject *parent) :
	QObject (parent)
{
	this->m_author = new TwitterUser (parent);
}

Tweet::Tweet (QString text, TwitterUser *author, QObject *parent) :
	QObject (parent)
{
	this->m_id = 0;
	this->setText(text);

	if (author)
		this->m_author = new TwitterUser (parent);

	else
	{
		this->m_author = author;
		author->setParent (this);
	}
}

Tweet::~Tweet()
{
	m_author->deleteLater();
}

Tweet::Tweet(const Tweet& original): QObject()
{
    this->m_author = original.author();
    this->m_created = original.dateTime();
    this->setText(original.text());
    this->m_id = original.id();
}

Tweet& Tweet::operator = (const Tweet &rhs)
{
	if (this == &rhs)				// Same object?
		return *this;				// Yes, so skip assignment, and just return *this.

	this->m_id = rhs.id();
	this->m_author = rhs.author();
	this->m_created = rhs.dateTime();
	this->setText(rhs.text());

	return *this;
}

bool Tweet::operator == (const Tweet &other)
{
	return (this->m_id == other.id());
}

bool Tweet::operator != (const Tweet &other)
{
	return ! (*this == other);
}

bool Tweet::operator < (const Tweet &other)
{
	return (this->m_id < other.id());
}

bool Tweet::operator > (const Tweet &other)
{
	return (this->m_id > other.id());
}

void Tweet::setText (QString text) 
{
 QRegExp rx("\\s((http|https)://[a-z0-9]+([-.]{1}[a-z0-9]+)*.[a-z]{2,5}(([0-9]{1,5})?/?.*))(\\s|,|$)");
 rx.setMinimal(true);
 
 qDebug() << "Parsing links for tweet " << m_id;
 
 if (rx.indexIn(text) != -1) {
  for (auto link : rx.capturedTexts())
  {
   qDebug() << link;
  }
  qDebug() << "The link: " << rx.capturedTexts()[1];
 }
 m_text = text;
 
 QString html = text;
 
 int pos = 0;
 
 while ( (pos = rx.indexIn(html, pos)) != -1 ) {
  if ( rx.cap(1).startsWith("http") ) {
   qDebug() << "Found one link";
   QString before = rx.cap( 1 );
   if (before.endsWith("."))
    before.chop(1);
   qDebug() << "Before=" << before;
   QString after = " <a href=\"" + before + "\">" + before + "</a>";
   qDebug() << "After=" << after;
   html.replace( pos, before.length() + 1, after );
   pos += after.length();
  } else {
   pos += rx.matchedLength();
  }
 }
 
 qDebug() << "HTML: " << html;
 
 m_document.setHtml(html);
}

    
}
}
// kate: indent-mode cstyle; indent-width 1; replace-tabs on; 
