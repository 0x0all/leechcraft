/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2006-2014  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include "storage.h"
#include <stdexcept>
#include <QFile>
#include <QApplication>
#include <QtConcurrentMap>
#include <QSqlDatabase>
#include <QSqlQuery>
#include <QSqlError>
#include <QDataStream>
#include <QtConcurrentRun>
#include <util/db/dblock.h>
#include <util/sys/paths.h>
#include <util/threads/futures.h>
#include "xmlsettingsmanager.h"
#include "account.h"
#include "accountdatabase.h"
#include "messageinfo.h"
#include "messagebodies.h"

namespace LeechCraft
{
namespace Snails
{
	namespace
	{
		template<typename T>
		QByteArray Serialize (const T& t)
		{
			QByteArray result;
			QDataStream stream (&result, QIODevice::WriteOnly);
			stream << t;
			return result;
		}
	}

	Storage::Storage (QObject *parent)
	: QObject (parent)
	{
		SDir_ = Util::CreateIfNotExists ("snails/storage");
	}

	void Storage::SaveMessageInfos (Account *acc, const QList<MessageInfo>& infos)
	{
		const auto& base = BaseForAccount (acc);
		for (const auto& info : infos)
			base->AddMessage (info);
	}

	QList<MessageInfo> Storage::GetMessageInfos (Account *acc, const QStringList& folder)
	{
		return BaseForAccount (acc)->GetMessageInfos (folder);
	}

	void Storage::SaveMessageBodies (Account *acc,
			const QStringList& folder,
			const QByteArray& msgId,
			const MessageBodies& bodies)
	{
		BaseForAccount (acc)->SaveMessageBodies (folder, msgId, bodies);
	}

	std::optional<MessageBodies> Storage::GetMessageBodies (Account *acc,
			const QStringList& folder, const QByteArray& msgId)
	{
		return BaseForAccount (acc)->GetMessageBodies (folder, msgId);
	}

	QList<QByteArray> Storage::LoadIDs (Account *acc, const QStringList& folder)
	{
		return BaseForAccount (acc)->GetIDs (folder);
	}

	std::optional<QByteArray> Storage::GetLastID (Account *acc, const QStringList& folder)
	{
		return BaseForAccount (acc)->GetLastID (folder);
	}

	void Storage::RemoveMessage (Account *acc, const QStringList& folder, const QByteArray& id)
	{
		BaseForAccount (acc)->RemoveMessage (id, folder);
	}

	int Storage::GetNumMessages (Account *acc, const QStringList& folder)
	{
		return BaseForAccount (acc)->GetMessageCount (folder);
	}

	int Storage::GetNumUnread (Account *acc, const QStringList& folder)
	{
		return BaseForAccount (acc)->GetUnreadMessageCount (folder);
	}

	bool Storage::IsMessageRead (Account *acc, const QStringList& folder, const QByteArray& id)
	{
		return BaseForAccount (acc)->IsMessageRead (id, folder).value ();
	}

	void Storage::SetMessagesRead (Account *acc,
			const QStringList& folder, const QList<QByteArray>& folderIds, bool read)
	{
		if (folderIds.isEmpty ())
			return;

		auto base = BaseForAccount (acc);

		qDebug () << "SetRead" << folderIds.size ();
		auto ts = base->BeginTransaction ();
		for (const auto& id : folderIds)
			base->SetMessageRead (id, folder, read);
		ts.Good ();
		qDebug () << "done";
	}

	QDir Storage::DirForAccount (const Account *acc) const
	{
		const QByteArray& id = acc->GetID ().toHex ();

		QDir dir = SDir_;
		if (!dir.exists (id))
			dir.mkdir (id);
		if (!dir.cd (id))
		{
			qWarning () << Q_FUNC_INFO
					<< "unable to cd into"
					<< dir.filePath (id);
			throw std::runtime_error ("Unable to cd to the dir");
		}

		return dir;
	}

	AccountDatabase_ptr Storage::BaseForAccount (const Account *acc)
	{
		if (AccountBases_.contains (acc))
			return AccountBases_ [acc];

		const auto& dir = DirForAccount (acc);
		const auto& base = std::make_shared<AccountDatabase> (dir, acc);
		AccountBases_ [acc] = base;
		return base;
	}
}
}
