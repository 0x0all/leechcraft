/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2006-2014  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include "sessionsmanager.h"
#include <QSettings>
#include <QCoreApplication>
#include <QStringList>
#include <QTimer>
#include <QInputDialog>
#include <QMainWindow>
#include <QtDebug>
#include <interfaces/iinfo.h>
#include <interfaces/ihavetabs.h>
#include <interfaces/ihaverecoverabletabs.h>
#include <interfaces/core/ipluginsmanager.h>
#include <interfaces/core/irootwindowsmanager.h>
#include <interfaces/core/icoretabwidget.h>
#include <util/sll/qtutil.h>
#include "recinfo.h"
#include "restoresessiondialog.h"
#include "util.h"

namespace LeechCraft
{
namespace TabSessManager
{
	SessionsManager::SessionsManager (const ICoreProxy_ptr& proxy, QObject *parent)
	: QObject { parent }
	, Proxy_ { proxy }
	{
		const auto& roots = Proxy_->GetPluginsManager ()->
				GetAllCastableRoots<IHaveTabs*> ();
		for (const auto root : roots)
			connect (root,
					SIGNAL (addNewTab (QString, QWidget*)),
					this,
					SLOT (handleNewTab (QString, QWidget*)),
					Qt::QueuedConnection);

		const auto rootWM = Proxy_->GetRootWindowsManager ();
		for (int i = 0; i < rootWM->GetWindowsCount (); ++i)
			handleWindow (i);

		connect (rootWM->GetQObject (),
				SIGNAL (windowAdded (int)),
				this,
				SLOT (handleWindow (int)));
	}

	QStringList SessionsManager::GetCustomSessions () const
	{
		QSettings settings { QCoreApplication::organizationName (),
				QCoreApplication::applicationName () + "_TabSessManager" };
		return settings.childGroups ();
	}

	namespace
	{
		QHash<QObject*, QList<RecInfo>> GetTabsFromStream (QDataStream& str, ICoreProxy_ptr proxy)
		{
			QHash<QByteArray, QObject*> pluginCache;
			QHash<QObject*, QList<RecInfo>> tabs;

			int order = 0;
			while (!str.atEnd ())
			{
				QByteArray pluginId;
				QByteArray recData;
				QString name;
				QIcon icon;
				QList<QPair<QByteArray, QVariant>> props;
				int winId = 0;

				str >> pluginId >> recData >> name >> icon >> props >> winId;
				if (!pluginCache.contains (pluginId))
				{
					const auto obj = proxy->GetPluginsManager ()->GetPluginByID (pluginId);
					pluginCache [pluginId] = obj;
				}

				const auto plugin = pluginCache [pluginId];
				if (!plugin)
				{
					qWarning () << "null plugin for" << pluginId;
					continue;
				}

				tabs [plugin] << RecInfo { order++, recData, props, name, icon, winId };

				qDebug () << Q_FUNC_INFO << "got restore data for"
						<< pluginId << name << plugin << "; window" << winId;
			}

			for (const auto obj : tabs.keys ({}))
				tabs.remove (obj);

			return tabs;
		}

		void AskTabs (QHash<QObject*, QList<RecInfo>>& tabs)
		{
			if (tabs.isEmpty ())
				return;

			RestoreSessionDialog dia;
			dia.SetTabs (tabs);

			if (dia.exec () != QDialog::Accepted)
			{
				tabs.clear ();
				return;
			}

			tabs = dia.GetTabs ();
		}
	}

	void SessionsManager::HandlePreferredWindowIndex (const IHookProxy_ptr& proxy, const QWidget*)
	{
		if (PreferredWindowsQueue_.empty ())
			return;

		proxy->SetReturnValue (PreferredWindowsQueue_.takeFirst ());
		proxy->CancelDefault ();
	}

	void SessionsManager::HandleTabAdding (QWidget *widget)
	{
	}

	bool SessionsManager::HasTab (QObject *tab)
	{
		return std::any_of (Tabs_.begin (), Tabs_.end (),
				[tab] (const QList<QObject*>& list) { return list.indexOf (tab) != -1; });
	}

	bool SessionsManager::eventFilter (QObject*, QEvent *e)
	{
		if (e->type () != QEvent::DynamicPropertyChange)
			return false;

		auto propEvent = static_cast<QDynamicPropertyChangeEvent*> (e);
		if (propEvent->propertyName ().startsWith ("SessionData/"))
			handleTabRecoverDataChanged ();

		return false;
	}

	namespace
	{
		void WriteRecoverableTab (QDataStream& str, int windowIndex,
				QObject *tab, IRecoverableTab *rec, IInfo *plugin)
		{
			const auto& data = rec->GetTabRecoverData ();
			if (data.isEmpty ())
				return;

			const QIcon forRecover { rec->GetTabRecoverIcon ().pixmap (32, 32) };

			str << plugin->GetUniqueID ()
					<< data
					<< rec->GetTabRecoverName ()
					<< forRecover
					<< GetSessionProps (tab)
					<< windowIndex;
		}

		void WriteSingleTab (QDataStream& str, int windowIndex,
				QObject *tab, const TabClassInfo& tc, IInfo *plugin)
		{
			qDebug () << Q_FUNC_INFO;
			str << plugin->GetUniqueID ()
					<< tc.TabClass_
					<< tc.VisibleName_
					<< tc.Icon_.pixmap (32, 32)
					<< GetSessionProps (tab)
					<< windowIndex;
		}

		bool IsGoodSingleTC (const TabClassInfo& tc)
		{
			return tc.Features_ & TabFeature::TFSingle && tc.Features_ & TabFeature::TFOpenableByRequest;
		}
	}

	QByteArray SessionsManager::GetCurrentSession () const
	{
		QByteArray result;
		QDataStream str (&result, QIODevice::WriteOnly);

		int windowIndex = 0;
		qDebug () << Q_FUNC_INFO << Tabs_.size ();
		for (const auto& list : Tabs_)
		{
			qDebug () << windowIndex << list.size ();
			for (auto tab : list)
			{
				auto tw = qobject_cast<ITabWidget*> (tab);
				if (!tw)
					continue;

				auto plugin = qobject_cast<IInfo*> (tw->ParentMultiTabs ());
				if (!plugin)
					continue;

				if (const auto rec = qobject_cast<IRecoverableTab*> (tab))
					WriteRecoverableTab (str, windowIndex, tab, rec, plugin);
				else
				{
					const auto& tc = tw->GetTabClassInfo ();
					if (IsGoodSingleTC (tc))
						WriteSingleTab (str, windowIndex, tab, tc, plugin);
				}
			}

			++windowIndex;
		}

		return result;
	}

	void SessionsManager::OpenTabs (const QHash<QObject*, QList<RecInfo>>& tabs)
	{
		QList<QPair<QObject*, RecInfo>> ordered;
		for (auto i = tabs.begin (); i != tabs.end (); ++i)
			for (const auto& info : i.value ())
				ordered.append ({ i.key (), info });

#ifdef USE_CPP14
		std::sort (ordered.begin (), ordered.end (),
				[] (const auto& left, const auto& right)
					{ return left.second.Order_ < right.second.Order_; });
#else
		std::sort (ordered.begin (), ordered.end (),
				[] (decltype (ordered.at (0)) left, decltype (ordered.at (0)) right)
					{ return left.second.Order_ < right.second.Order_; });
#endif

		for (const auto& pair : ordered)
		{
			PreferredWindowsQueue_ << pair.second.WindowID_;
			const auto& props = pair.second.Props_;
			if (const auto ihrt = qobject_cast<IHaveRecoverableTabs*> (pair.first))
				ihrt->RecoverTabs ({ TabRecoverInfo { pair.second.Data_, props } });
			else if (const auto iht = qobject_cast<IHaveTabs*> (pair.first))
				iht->TabOpenRequested (pair.second.Data_);
		}
	}

	void SessionsManager::recover ()
	{
		QSettings settings { QCoreApplication::organizationName (),
				QCoreApplication::applicationName () + "_TabSessManager" };

		QDataStream str (settings.value ("Data").toByteArray ());
		auto tabs = GetTabsFromStream (str, Proxy_);

		if (!settings.value ("CleanShutdown", false).toBool ())
			AskTabs (tabs);

		OpenTabs (tabs);

		IsRecovering_ = false;
		settings.setValue ("CleanShutdown", false);
	}

	void SessionsManager::handleTabRecoverDataChanged ()
	{
		if (IsRecovering_ || Proxy_->IsShuttingDown ())
			return;

		if (IsScheduled_)
			return;

		IsScheduled_ = true;
		QTimer::singleShot (2000,
				this,
				SLOT (saveDefaultSession ()));
	}

	void SessionsManager::saveDefaultSession ()
	{
		qDebug () << Q_FUNC_INFO;
		IsScheduled_ = false;

		const auto& result = GetCurrentSession ();

		QSettings settings (QCoreApplication::organizationName (),
				QCoreApplication::applicationName () + "_TabSessManager");
		settings.setValue ("Data", result);
	}

	void SessionsManager::saveCustomSession ()
	{
		auto rootWM = Proxy_->GetRootWindowsManager ();
		const QString& name = QInputDialog::getText (rootWM->GetPreferredWindow (),
				tr ("Custom session"),
				tr ("Enter the name of the session:"));
		if (name.isEmpty ())
			return;

		const auto& result = GetCurrentSession ();
		QSettings settings (QCoreApplication::organizationName (),
				QCoreApplication::applicationName () + "_TabSessManager");
		settings.beginGroup (name);
		settings.setValue ("Data", result);
		settings.endGroup ();

		emit gotCustomSession (name);
	}

	namespace
	{
		QHash<QObject*, QList<RecInfo>> GetSession (const QString& name, const ICoreProxy_ptr& proxy)
		{
			QSettings settings { QCoreApplication::organizationName (),
					QCoreApplication::applicationName () + "_TabSessManager" };
			settings.beginGroup (name);
			QDataStream str { settings.value ("Data").toByteArray () };
			settings.endGroup ();

			return GetTabsFromStream (str, proxy);
		}
	}

	void SessionsManager::loadCustomSession (const QString& name)
	{
		const auto rootMgr = Proxy_->GetRootWindowsManager ();
		for (int i = rootMgr->GetWindowsCount () - 1; i >= 0; --i)
		{
			const auto tabWidget = rootMgr->GetTabWidget (i);
			for (int j = tabWidget->WidgetCount () - 1; j >= 0; --j)
			{
				const auto tab = tabWidget->Widget (j);
				const auto itw = qobject_cast<ITabWidget*> (tab);
				itw->Remove ();
			}

			if (i)
				rootMgr->GetMainWindow (i)->close ();
		}

		OpenTabs (GetSession (name, Proxy_));
	}

	void SessionsManager::addCustomSession (const QString& name)
	{
		auto tabs = GetSession (name, Proxy_);

		QHash<QObject*, QList<QByteArray>> plugin2recoveries;
		for (const auto window : Tabs_)
			for (const auto tab : window)
			{
				const auto tw = qobject_cast<ITabWidget*> (tab);
				const auto rec = qobject_cast<IRecoverableTab*> (tab);
				if (!tw || !rec)
					continue;

				plugin2recoveries [tw->ParentMultiTabs ()] << rec->GetTabRecoverData ();
			}

		for (const auto& pair : Util::Stlize (tabs))
		{
			const auto& present = plugin2recoveries.value (pair.first);

			const auto ihrt = qobject_cast<IHaveRecoverableTabs*> (pair.first);
			auto& recList = pair.second;
			recList.erase (std::remove_if (recList.begin (), recList.end (),
						[&present, ihrt] (const RecInfo& info)
						{
							return present.contains (info.Data_) ||
									ihrt->HasSimilarTab (info.Data_, present);
						}),
					recList.end ());
		}

		OpenTabs (tabs);
	}

	void SessionsManager::deleteCustomSession (const QString& name)
	{
		QSettings settings { QCoreApplication::organizationName (),
				QCoreApplication::applicationName () + "_TabSessManager" };
		settings.remove (name);
	}

	void SessionsManager::handleRemoveTab (QWidget *widget)
	{
		for (auto& list : Tabs_)
			list.removeAll (widget);
		handleTabRecoverDataChanged ();
	}

	void SessionsManager::handleNewTab (const QString&, QWidget *widget)
	{
		if (HasTab (widget))
			return;

		const auto rootWM = Proxy_->GetRootWindowsManager ();
		const auto itw = qobject_cast<ITabWidget*> (widget);
		const auto windowIndex = rootWM->GetWindowForTab (itw);

		if (windowIndex < 0 || windowIndex >= Tabs_.size ())
		{
			qWarning () << Q_FUNC_INFO
					<< "unknown window index for"
					<< widget;
			return;
		}

		Tabs_ [windowIndex] << widget;

		const auto irt = qobject_cast<IRecoverableTab*> (widget);
		if (!irt && !IsGoodSingleTC (itw->GetTabClassInfo ()))
			return;

		if (irt)
			connect (widget,
					SIGNAL (tabRecoverDataChanged ()),
					this,
					SLOT (handleTabRecoverDataChanged ()));

		widget->installEventFilter (this);

		if (!irt || !irt->GetTabRecoverData ().isEmpty ())
			handleTabRecoverDataChanged ();

		const auto& posProp = widget->property ("TabSessManager/Position");
		if (posProp.isValid ())
		{
			const auto prevPos = posProp.toInt ();

			const auto tabWidget = rootWM->GetTabWidget (windowIndex);
			const auto currentIdx = tabWidget->IndexOf (widget);
			if (prevPos < tabWidget->WidgetCount () && currentIdx != prevPos)
				tabWidget->MoveTab (currentIdx, prevPos);
		}
	}

	void SessionsManager::handleTabMoved (int from, int to)
	{
		const auto rootWM = Proxy_->GetRootWindowsManager ();
		const auto tabWidget = qobject_cast<ICoreTabWidget*> (sender ());
		const auto pos = rootWM->GetTabWidgetIndex (tabWidget);

		auto& tabs = Tabs_ [pos];

		if (std::max (from, to) >= tabs.size () ||
			std::min (from, to) < 0)
		{
			qWarning () << Q_FUNC_INFO
					<< "invalid"
					<< from
					<< "->"
					<< to
					<< "; total tabs:"
					<< Tabs_.size ();
			return;
		}

		auto tab = tabs.takeAt (from);
		tabs.insert (to, tab);

		handleTabRecoverDataChanged ();
	}

	void SessionsManager::handleWindow (int index)
	{
		Tabs_ << QList<QObject*> {};
		connect (Proxy_->GetRootWindowsManager ()->GetTabWidget (index)->GetQObject (),
				SIGNAL (tabWasMoved (int, int)),
				this,
				SLOT (handleTabMoved (int, int)));
	}

	void SessionsManager::handleWindowRemoved (int index)
	{
		Tabs_.removeAt (index);
		handleTabRecoverDataChanged ();
	}
}
}
